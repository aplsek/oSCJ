Minimal SCJ implementation

diff -r 7e2669befe7e RealMakefile.in
--- a/RealMakefile.in	Thu Feb 25 19:27:42 2010 -0500
+++ b/RealMakefile.in	Thu Mar 04 20:52:23 2010 -0500
@@ -95,10 +95,10 @@
 	$(FIJI_JAVA_COMPILER) -nowarn -source 1.5 -target 1.5 -bootclasspath lib/fivmcommon.jar:lib/fijirt.jar:fijicore/build  $(FIJICORESRC) -d fijicore/build
 	$(JAR) cf lib/fijicore.jar -C fijicore/build .
 
-lib/fivmr.jar: $(FIVMRSRC) lib/fijicore.jar lib/fijirt.jar lib/fivmcommon.jar
+lib/fivmr.jar: $(FIVMRSRC) lib/fijicore.jar lib/fijirt.jar lib/fivmcommon.jar lib/fijiscj.jar
 	rm -rf runtimej/build
 	mkdir runtimej/build
-	$(FIJI_JAVA_COMPILER) -Xlint:unchecked -Xlint:deprecated -warn:-serial -source 1.5 -target 1.5 -bootclasspath lib/fijicore.jar:lib/fijirt.jar:lib/fivmcommon.jar $(FIVMRSRC) -d runtimej/build
+	$(FIJI_JAVA_COMPILER) -Xlint:unchecked -Xlint:deprecated -warn:-serial -source 1.5 -target 1.5 -bootclasspath lib/fijicore.jar:lib/fijirt.jar:lib/fivmcommon.jar:lib/fijiscj.jar $(FIVMRSRC) -d runtimej/build
 	$(JAR) cf lib/fivmr.jar -C runtimej/build .
 
 lib/rtsj.jar: $(RTSJSRC) lib/fivmr.jar lib/fijicore.jar lib/fijirt.jar lib/fivmcommon.jar
@@ -215,11 +215,11 @@
 	$(FIJI_JAVA_COMPILER) -Xlint:unchecked -Xlint:deprecated -source 1.5 -target 1.5 -classpath $(ASMLIBS):lib/fijirt.jar:lib/fivmcommon.jar:lib/fivmc.jar $(UTILSRC) -d util/build
 	$(JAR) cf lib/fivmutil.jar -C util/build .
 
-lib/fivmtest.jar: $(FIVMTESTSRC) lib/fivmr.jar lib/fijirt.jar lib/fivmcommon.jar lib/fijicore.jar lib/rtsj.jar
+lib/fivmtest.jar: $(FIVMTESTSRC) lib/fivmr.jar lib/fijirt.jar lib/fivmcommon.jar lib/fijicore.jar lib/rtsj.jar lib/fijiscj.jar
 	rm -rf test/build
 	mkdir test/build
 	(cd test/build && $(JAVA) -jar ../../lib/jasmin.jar `find ../src | grep \\\\.j$$`)
-	$(FIJI_JAVA_COMPILER) -nowarn -source 1.5 -target 1.5 -classpath lib/fivmr.jar:lib/fijirt.jar:lib/fivmcommon.jar:lib/fijicore.jar:lib/rtsj.jar:test/build $(FIVMTESTSRC) -d test/build
+	$(FIJI_JAVA_COMPILER) -nowarn -source 1.5 -target 1.5 -classpath lib/fivmr.jar:lib/fijirt.jar:lib/fivmcommon.jar:lib/fijicore.jar:lib/rtsj.jar:lib/fijiscj.jar:test/build $(FIVMTESTSRC) -d test/build
 	rm test/build/com/fiji/fivm/test/ClassWeDelete.class
 	$(JAR) cf lib/fivmtest.jar -C test/build .
 
@@ -396,7 +396,7 @@
 # doesn't imply ERC32 SIS (the user could have configured one of any number of
 # SIS-incompatible sparc BSPs).  second, we're not really married to rtems4.9.  so
 # why should our tests be?
-check: check-64 check-rtems check-waittest check-hfgc check-locktest check-cmrgc check-reflection check-cmrgc-fragmented check-cmrgc-disk check-nogc check-cmrgc-poisoned
+check: check-64 check-rtems check-waittest check-hfgc check-locktest check-cmrgc check-reflection check-cmrgc-fragmented check-cmrgc-disk check-nogc check-cmrgc-poisoned check-scopedmem
 	echo ALL TESTS PASSED
 
 check-64:
@@ -413,6 +413,7 @@
 check-hfgc: check-testnogc-hfgc-noopt check-testnogc-hfgc check-simplegctest-hfgc-noopt check-simplegctest-hfgc check-testnogc-hfgc-a check-simplegctest-hfgc-a
 check-locktest: check-locktest-fast check-locktest-biased
 check-waittest: check-waittest-fast check-waittest-biased check-waittest-fast-hfgc
+check-scopedmem: check-scopedmem-nogc check-scopedmem-cmrgc check-scopedmem-hfgc
 
 check-locktest-fast: lib/fivmtest.jar
 	time $(RUBY) bin/fivmc $(FIVMCFLAGS) -o locktest-fast lib/fivmtest.jar -m com/fiji/fivm/test/LockTest --more-opt --lock-impl fast --sanity-check 1
@@ -599,6 +600,18 @@
 	FIVMR_GC_MAX_MEM=1G FIVMR_GC_TRIGGER=200M time ./simplegctest-cmrgc-fragmented-forcearraylets 10 10000000 10
 	FIVMR_GC_MAX_MEM=500M FIVMR_GC_TRIGGER=10M time ./simplegctest-cmrgc-fragmented-forcearraylets 10 10000000 10
 
+check-scopedmem-nogc: lib/fivmtest.jar
+	time $(RUBY) bin/fivmc $(FIVMCFLAGS) --sanity-check 1 -o scopedmem-nogc lib/fivmtest.jar -m com/fiji/fivm/test/RawScopedMemoryTest --g-scoped-mem -G none
+	time ./scopedmem-nogc
+
+check-scopedmem-cmrgc: lib/fivmtest.jar
+	time $(RUBY) bin/fivmc $(FIVMCFLAGS) --sanity-check 1 -o scopedmem-cmrgc lib/fivmtest.jar -m com/fiji/fivm/test/RawScopedMemoryTest --g-scoped-mem -G cmr
+	time ./scopedmem-cmrgc
+
+check-scopedmem-hfgc: lib/fivmtest.jar
+	time $(RUBY) bin/fivmc $(FIVMCFLAGS) --sanity-check 1 -o scopedmem-hfgc lib/fivmtest.jar -m com/fiji/fivm/test/RawScopedMemoryTest --g-scoped-mem -G hf
+	time ./scopedmem-hfgc
+
 doc: javadoc
 	cp README doc/README.txt
 	cp LEGAL doc/LEGAL.txt
diff -r 7e2669befe7e bin/fivmc
--- a/bin/fivmc	Thu Feb 25 19:27:42 2010 -0500
+++ b/bin/fivmc	Thu Mar 04 20:52:23 2010 -0500
@@ -2241,7 +2241,6 @@
     result+=" -DFIVMR_MAX_THREADS=#{$maxThreads}" if $maxThreads
     result+=" -DFIVMR_SA_SIZE=#{$saSize}" if $saSize
     result+=" -DFIVMR_GC_DEF_PRIORITY=#{$gcThreadPriority}" if $gcThreadPriority
-    result+=" -DFIVMR_SCOPED_MEMORY=1" if $gcScopedMemory
     result
   end
 
@@ -2825,6 +2824,9 @@
             elsif $library=="GLIBJ"
               x.file osify($libdir+'glibj.zip')
             end
+            if $gcScopedMemory and not $scjApplication
+              x.file osify($libdir+'fijiscj.jar')
+            end
             if $scjApplication
               x.file osify($libdir+'scj.jar')
             end
diff -r 7e2669befe7e localbin/junkclean
--- a/localbin/junkclean	Thu Feb 25 19:27:42 2010 -0500
+++ b/localbin/junkclean	Thu Mar 04 20:52:23 2010 -0500
@@ -5,3 +5,4 @@
 find . -name '*.build' -and -type d -exec rm -r {} \; 2>/dev/null
 
 rm -f testnogc* simplegctest* locktest-* waittest-* testreflection
+rm -f scopedmem-*
diff -r 7e2669befe7e runtimec/src/fivmr.h
--- a/runtimec/src/fivmr.h	Thu Feb 25 19:27:42 2010 -0500
+++ b/runtimec/src/fivmr.h	Thu Mar 04 20:52:23 2010 -0500
@@ -709,6 +709,7 @@
 struct fivmr_GCSpaceAlloc_s;
 struct fivmr_GCData_s;
 struct fivmr_ScopeID_s;
+struct fivmr_MemoryArea_s;
 #if FIVMR_DYN_LOADING && !FIVMR_STATIC_JNI
 struct fivmr_JNILib_s;
 #endif
@@ -732,6 +733,8 @@
 typedef struct fivmr_GCData_s fivmr_GCData;
 typedef struct fivmr_GCHeader_s fivmr_GCHeader;
 typedef struct fivmr_ScopeID_s fivmr_ScopeID;
+typedef struct fivmr_MemoryArea_s fivmr_MemoryArea;
+typedef struct fivmr_MemoryAreaStack_s fivmr_MemoryAreaStack;
 typedef struct fivmr_FreePage_s fivmr_FreePage;
 typedef struct fivmr_UsedPage_s fivmr_UsedPage;
 typedef struct fivmr_GCSpaceData_s fivmr_GCSpaceData;
@@ -1021,6 +1024,27 @@
     uintptr_t word;
 };
 
+struct fivmr_MemoryArea_s {
+    uintptr_t totalsize;
+
+    uintptr_t start;
+    uintptr_t bump;
+    uintptr_t size;
+
+    /* FIXME: This object pointer requires that the BackingStoreID
+     * never moves! */
+    fivmr_Object bsid;
+
+    fivmr_ScopeID *scopeID;
+
+    fivmr_MemoryArea *parent;
+};
+
+struct fivmr_MemoryAreaStack_s {
+    fivmr_MemoryArea *area;
+    fivmr_MemoryAreaStack *prev;
+};
+
 struct fivmr_FreeLine_s {
     fivmr_FreeLine *prev;
     fivmr_FreeLine *next;
@@ -1070,6 +1094,16 @@
     uintptr_t invCurShaded;
     uintptr_t zeroCurShaded;
     uintptr_t curShadedAlloc;
+
+
+    /* Two pointer words, a fivmr_MemoryArea (8 words), and a
+     * fivmr_MemoryAreaStack (2 words) per thread of overhead when scoped
+     * memory is not in use. */
+    fivmr_MemoryAreaStack *scopeStack;
+    fivmr_MemoryArea *currentArea;
+    fivmr_MemoryArea heapMemoryArea;
+    fivmr_MemoryArea immortalMemoryArea;
+    fivmr_MemoryAreaStack baseStackEntry;
 };
 
 struct fivmr_Destructor_s {
@@ -1553,6 +1587,9 @@
     fivmr_TypeData *td_ClassArr;
 };
 
+/* FIXME: Should not be using globals here! */
+extern fivmr_MemoryArea fivmr_stackMemoryArea;
+
 struct fivmr_GC_s {
     /* most of what follows is for CMRGC and HFGC */
     int32_t phase;
@@ -2669,6 +2706,9 @@
     return fivmr_ObjHeader_getMonitor(settings,header)->forward;
 }
 
+/* fivmr_stampGCBits() is called only by large object allocation in the
+ * C-side slow path.  It is therefore provided only for reference for
+ * the NOGC case, since this path does not exist. */
 static inline void fivmr_stampGCBits(fivmr_GC *gc,
                                      fivmr_GCSpace space,
                                      fivmr_ScopeID *s,
@@ -3463,6 +3503,148 @@
     ts->pollingUnion.s.pollchecksDisabled--;
 }
 
+void fivmr_MemoryArea_doRun(uintptr_t ts, fivmr_Object bsid,
+                            fivmr_Object logic);
+fivmr_Object fivmr_MemoryArea_getBSID(uintptr_t ts, uintptr_t area);
+
+static inline uintptr_t fivmr_MemoryArea_push(fivmr_ThreadState *ts,
+                                              int64_t size,
+                                              fivmr_Object bsid) {
+    fivmr_MemoryArea *area;
+    fivmr_MemoryAreaStack *ms;
+    /* Enforce a linear stack -- no cactus stacks! */
+    fivmr_assert(ts->gc.scopeStack->area==ts->gc.currentArea);
+    area=fivmr_malloc(sizeof(fivmr_MemoryArea) + size);
+    ms=fivmr_malloc(sizeof(fivmr_MemoryAreaStack));
+    bzero(area,sizeof(*area));
+    /* FIXME: Depends on an unmoving BackingStoreID object! */
+    area->bsid=bsid;
+    area->parent=ts->gc.currentArea;
+    area->size=area->totalsize=size;
+    area->bump=area->start=(uintptr_t)(area+1)
+        +FIVMR_ALLOC_OFFSET(&ts->gc.settings);
+    ms->area=area;
+    ms->prev=ts->gc.scopeStack;
+    ts->gc.scopeStack=ms;
+    return (uintptr_t)area;
+}
+
+static inline uintptr_t fivmr_MemoryArea_pop(fivmr_ThreadState *ts) {
+    fivmr_MemoryAreaStack *ms=ts->gc.scopeStack;
+    fivmr_Object bsid;
+    fivmr_assert(ms);
+    fivmr_assert(ms!=&ts->gc.baseStackEntry);
+    fivmr_assert(ms->area->scopeID==NULL);
+    ts->gc.scopeStack=ms->prev;
+    bsid=fivmr_MemoryArea_getBSID((uintptr_t)ts, (uintptr_t)ms->area);
+    fivmr_free(ms->area);
+    fivmr_free(ms);
+    return (uintptr_t)bsid;
+}
+
+static inline void fivmr_MemoryArea_doSetArea(fivmr_ThreadState *ts,
+                                              fivmr_MemoryArea *prevArea,
+                                              fivmr_MemoryArea *newArea) {
+    ts->gc.currentArea=newArea;
+    fivmr_assert(newArea);
+    if (newArea==prevArea)
+        return;
+    if (newArea!=&ts->gc.heapMemoryArea)
+        fivmr_assert(newArea->scopeID);
+    prevArea->bump=ts->gc.alloc[0].bump;
+    prevArea->start=ts->gc.alloc[0].start;
+    prevArea->size=ts->gc.alloc[0].size;
+    ts->gc.alloc[0].bump=newArea->bump;
+    ts->gc.alloc[0].start=newArea->start;
+    ts->gc.alloc[0].size=newArea->size;
+}
+
+static inline void fivmr_MemoryArea_enter(fivmr_ThreadState *ts,
+                                          fivmr_MemoryArea *area,
+                                          fivmr_Object logic) {
+    fivmr_ScopeID scope={ (uintptr_t)area | FIVMR_SCOPEID_SCOPE };
+    fivmr_MemoryArea *prevArea=ts->gc.currentArea;
+    fivmr_assert(ts->gc.currentArea==area->parent);
+    /* Should be implied by the above */
+    fivmr_assert(area->scopeID==NULL);
+    area->scopeID=&scope;
+    /* FIXME: We shouldn't have to bzero the entire memory area at enter */
+    bzero((void *)(area+1),area->totalsize);
+    LOG(3, ("Entering memory area %p in thread %d", area, ts->id));
+    fivmr_MemoryArea_doSetArea(ts,prevArea,area);
+    fivmr_fence();
+    fivmr_MemoryArea_doRun((uintptr_t)ts,
+                           fivmr_MemoryArea_getBSID((uintptr_t)ts,
+                                                    (uintptr_t)area),
+                           logic);
+    fivmr_fence();
+    LOG(3, ("Exiting memory area %p in thread %d", area, ts->id));
+    if (ts->gc.currentArea==area) {
+        fivmr_MemoryArea_doSetArea(ts,area,prevArea);
+    }
+    area->scopeID=NULL;
+    area->size=area->totalsize;
+    area->bump=area->start;
+}
+
+static inline uintptr_t
+fivmr_MemoryArea_setCurrentArea(fivmr_ThreadState *ts,
+                                fivmr_MemoryArea *area) {
+    uintptr_t prev;
+    fivmr_assert(area);
+    fivmr_assert(area==&ts->gc.heapMemoryArea||area->scopeID);
+    prev=(uintptr_t)ts->gc.currentArea;
+    LOG(3, ("Setting current memory area to %p in thread %d", area, ts->id));
+    fivmr_MemoryArea_doSetArea(ts,ts->gc.currentArea,area);
+    return prev;
+}
+
+static inline fivmr_MemoryArea *fivmr_MemoryArea_forObject(
+    fivmr_ThreadState *ts, fivmr_Object o)
+{
+    fivmr_GCHeader *hdr=fivmr_GCHeader_fromObject(&ts->vm->settings, o);
+    if (fivmr_GCHeader_isImmortal(hdr)) {
+        return &ts->gc.immortalMemoryArea;
+    } else if (fivmr_GCHeader_markBits(hdr)) {
+        return &ts->gc.heapMemoryArea;
+    } else {
+        fivmr_ScopeID *scopeid=fivmr_GCHeader_frame(hdr);
+        if (scopeid->word&FIVMR_SCOPEID_STACK) {
+            return &fivmr_stackMemoryArea;
+        } else {
+            return (fivmr_MemoryArea*)(scopeid->word&~FIVMR_SCOPEID_MASK);
+        }
+    }
+}
+
+static inline uintptr_t fivmr_MemoryArea_getImmortalArea(
+    fivmr_ThreadState *ts) {
+    return (uintptr_t)&ts->gc.immortalMemoryArea;
+}
+
+static inline uintptr_t fivmr_MemoryArea_getHeapArea(fivmr_ThreadState *ts) {
+    return (uintptr_t)&ts->gc.heapMemoryArea;
+}
+
+#define FIVMR_MEMORYAREA_HEAP 1
+#define FIVMR_MEMORYAREA_IMMORTAL 2
+
+static inline fivmr_MemoryArea *fivmr_MemoryArea_getThreadSpecific(
+    fivmr_ThreadState *ts, int areaid)
+{
+    if (areaid == FIVMR_MEMORYAREA_HEAP) {
+        return &ts->gc.heapMemoryArea;
+    } else if (areaid == FIVMR_MEMORYAREA_IMMORTAL) {
+        return &ts->gc.immortalMemoryArea;
+    } else {
+        return NULL;
+    };
+}
+
+static inline uintptr_t fivmr_MemoryArea_getStackArea() {
+    return (uintptr_t)&fivmr_stackMemoryArea;
+}
+
 /* soft handshake support. */
 void fivmr_ThreadState_softHandshake(fivmr_VM *vm,
                                      uintptr_t requiredExecFlags,
diff -r 7e2669befe7e runtimec/src/fivmr_cmrgc.c
--- a/runtimec/src/fivmr_cmrgc.c	Thu Feb 25 19:27:42 2010 -0500
+++ b/runtimec/src/fivmr_cmrgc.c	Thu Mar 04 20:52:23 2010 -0500
@@ -1075,10 +1075,17 @@
 					fivmr_GCSpace space) {
     fivmr_GC *gc;
     fivmr_GCSpaceAlloc *alloc;
+    fivmr_MemoryArea *curarea;
     
     gc=&ts->vm->gc;
     alloc=ts->gc.alloc+space;
-
+    curarea=NULL;
+    
+    if (FIVMR_SCOPED_MEMORY(&ts->vm->settings)&&space==0&&
+        ts->gc.currentArea!=ts->gc.baseStackEntry.area) {
+        curarea=ts->gc.currentArea;
+        fivmr_MemoryArea_setCurrentArea(ts, ts->gc.baseStackEntry.area);
+    }
     if (alloc->bump) {
         relinquishAllocationContextForPage(ts,space,alloc->start);
     } else {
@@ -1086,16 +1093,28 @@
 	fivmr_assert(alloc->freeTail==NULL);
 	fivmr_assert(alloc->usedPage==NULL);
     }
+    if (curarea) {
+        fivmr_MemoryArea_setCurrentArea(ts, curarea);
+    }
 }
 
 static void relinquishAllocationContexts(fivmr_ThreadState *ts) {
     fivmr_GCSpace i;
+    fivmr_MemoryArea *curarea=NULL;
+    if (FIVMR_SCOPED_MEMORY(&ts->vm->settings)&&
+        ts->gc.currentArea!=ts->gc.baseStackEntry.area) {
+        curarea=ts->gc.currentArea;
+        fivmr_MemoryArea_setCurrentArea(ts, ts->gc.baseStackEntry.area);
+    }
     if (FIVMR_HFGC(&ts->vm->settings)) {
         relinquishSpacesContext(ts);
     }
     for (i=0;i<FIVMR_GC_NUM_GC_SPACES;++i) {
 	relinquishAllocationContext(ts,i);
     }
+    if (FIVMR_SCOPED_MEMORY(&ts->vm->settings)&&curarea) {
+        fivmr_MemoryArea_setCurrentArea(ts, curarea);
+    }
 }
 
 static void initSpaces(fivmr_GC *gc) {
@@ -2946,6 +2965,12 @@
         fivmr_assert(ts->gc.alloc[i].ssEnd==0);
         fivmr_assert(ts->gc.alloc[i].ssSize==0);
     }
+    if (FIVMR_SCOPED_MEMORY(&ts->vm->settings)) {
+        fivmr_assert(ts->gc.currentArea==&ts->gc.heapMemoryArea);
+        fivmr_assert(ts->gc.baseStackEntry.area==ts->gc.currentArea);
+        fivmr_assert(ts->gc.baseStackEntry.prev==NULL);
+        fivmr_assert(ts->gc.scopeStack==&ts->gc.baseStackEntry);
+    }
 }
 
 /* calls should be protected by the thread's lock. */
@@ -2954,6 +2979,7 @@
     fivmr_Frame *f;
     fivmr_NativeFrame *nf;
     uintptr_t i;
+    fivmr_MemoryAreaStack *ms;
     
     vm=ts->vm;
     
@@ -3031,6 +3057,13 @@
 	    mutatorMarkHandleNoisy(ts,h);
 	}
     }
+
+    if (FIVMR_SCOPED_MEMORY(&ts->vm->settings)) {
+        /* mark BackingStoreID objects on the scope stack */
+        for (ms=ts->gc.scopeStack;ms!=NULL;ms=ms->prev) {
+            mutatorMarkObjNoisy(ts,ms->area->bsid);
+        }
+    }
 }
 
 static void pushShadeValues(fivmr_ThreadState *ts) {
@@ -3116,7 +3149,15 @@
 }
 
 void FIVMR_CONCAT(FIVMBUILD_GC_NAME,_clear)(fivmr_ThreadState *ts) {
-    /* all of this stuff should have been cleared by the thread
+    if (FIVMR_SCOPED_MEMORY(&ts->vm->settings)) {
+        ts->gc.currentArea=&ts->gc.heapMemoryArea;
+        ts->gc.baseStackEntry.area=ts->gc.currentArea;
+        ts->gc.baseStackEntry.prev=NULL;
+        ts->gc.scopeStack=&ts->gc.baseStackEntry;
+        ts->gc.immortalMemoryArea.scopeID=(fivmr_ScopeID*)-1;
+    }
+
+    /* all the rest of this stuff should have been cleared by the thread
        tear down. */
     assertGCDataClear(ts);
 }
@@ -3132,6 +3173,11 @@
     LOG(2,("Thread %u committing; committing its queue and relinquishing its page.",ts->id));
     fivmr_Lock_lock(&ts->lock);
     commitQueue(ts);
+    if (FIVMR_SCOPED_MEMORY(&ts->vm->settings)) {
+        while (ts->gc.scopeStack->prev) {
+            fivmr_MemoryArea_pop(ts);
+        }
+    }
     relinquishAllocationContexts(ts);
     fivmr_Lock_unlock(&ts->lock);
     assertGCDataClear(ts);
diff -r 7e2669befe7e runtimec/src/fivmr_monitor.c
--- a/runtimec/src/fivmr_monitor.c	Thu Feb 25 19:27:42 2010 -0500
+++ b/runtimec/src/fivmr_monitor.c	Thu Mar 04 20:52:23 2010 -0500
@@ -591,8 +591,21 @@
 	    uintptr_t state;
 	    
 	    fivmr_assert(curMonitor==(void*)curMonitor->forward);
-	    
-	    newMonitor=fivmr_allocRawType(ts,fivmr_Monitor);
+
+            if (FIVMR_SCOPED_MEMORY(&ts->vm->settings)) {
+                fivmr_MemoryArea *curarea=ts->gc.currentArea;
+                fivmr_MemoryArea *objarea=fivmr_MemoryArea_forObject(
+                    ts,fivmr_ObjHeader_toObject(&ts->vm->settings,head));
+                if (curarea!=objarea) {
+                    fivmr_MemoryArea_setCurrentArea(ts,objarea);
+                }
+                newMonitor=fivmr_allocRawType(ts,fivmr_Monitor);
+                if (curarea!=objarea) {
+                    fivmr_MemoryArea_setCurrentArea(ts,curarea);
+                }
+            } else {
+                newMonitor=fivmr_allocRawType(ts,fivmr_Monitor);
+            }
 	    
 	    LOG(5,("Thread %u: monitor at = %p",ts->id,newMonitor));
 	    
diff -r 7e2669befe7e runtimec/src/fivmr_nogc.c
--- a/runtimec/src/fivmr_nogc.c	Thu Feb 25 19:27:42 2010 -0500
+++ b/runtimec/src/fivmr_nogc.c	Thu Mar 04 20:52:23 2010 -0500
@@ -15,6 +15,13 @@
     ts->gc.alloc[0].bump=0;
     ts->gc.alloc[0].start=0;
     ts->gc.alloc[0].size=0;
+    if (FIVMR_SCOPED_MEMORY(&ts->vm->settings)) {
+        ts->gc.currentArea=&ts->gc.immortalMemoryArea;
+        ts->gc.baseStackEntry.area=ts->gc.currentArea;
+        ts->gc.baseStackEntry.prev=NULL;
+        ts->gc.scopeStack=&ts->gc.baseStackEntry;
+        ts->gc.immortalMemoryArea.scopeID=(fivmr_ScopeID*)-1;
+    }
 }
 
 void fivmr_NOGC_startThread(fivmr_ThreadState *ts) {}
diff -r 7e2669befe7e runtimec/src/fivmr_posix_nanos.c
--- a/runtimec/src/fivmr_posix_nanos.c	Thu Feb 25 19:27:42 2010 -0500
+++ b/runtimec/src/fivmr_posix_nanos.c	Thu Mar 04 20:52:23 2010 -0500
@@ -4,6 +4,18 @@
 #include "fivmr.h"
 #include <sys/time.h>
 
+fivmr_Nanos fivmr_nanosResolution() {
+#ifdef HAVE_CLOCK_GETTIME
+    struct timespec ts;
+
+    clock_getres(CLOCK_REALTIME, &ts);
+
+    return ts.tv_nsec;
+#else
+    return 1000;
+#endif
+}
+
 fivmr_Nanos fivmr_curTime(void) {
     fivmr_Nanos result;
 
diff -r 7e2669befe7e runtimec/src/fivmr_rtems_nanos.c
--- a/runtimec/src/fivmr_rtems_nanos.c	Thu Feb 25 19:27:42 2010 -0500
+++ b/runtimec/src/fivmr_rtems_nanos.c	Thu Mar 04 20:52:23 2010 -0500
@@ -4,6 +4,12 @@
 #include "fivmr.h"
 #include <sys/time.h>
 
+fivmr_Nanos fivmr_nanosResolution() {
+    /* FIXME: How can we get this resolution?  Doesn't seem to be
+     * rtems_clock_get_ticks_per_second() */
+    return 1000;
+}
+
 fivmr_Nanos fivmr_curTime(void) {
     fivmr_Nanos result;
     struct timespec ts;
diff -r 7e2669befe7e runtimec/src/fivmr_runtime.c
--- a/runtimec/src/fivmr_runtime.c	Thu Feb 25 19:27:42 2010 -0500
+++ b/runtimec/src/fivmr_runtime.c	Thu Mar 04 20:52:23 2010 -0500
@@ -4,6 +4,10 @@
 fivmr_VM *fivmr_vmListHead;
 fivmr_Lock fivmr_vmListLock;
 
+/* FIXME */
+fivmr_MemoryArea fivmr_immortalMemoryArea;
+fivmr_MemoryArea fivmr_stackMemoryArea;
+
 #if FIVMR_PF_POLLCHECK
 static void pagefault_handler(int sig,siginfo_t *info,void *arg) {
     fivmr_VM *vm;
diff -r 7e2669befe7e runtimec/src/fivmr_sysdep.h
--- a/runtimec/src/fivmr_sysdep.h	Thu Feb 25 19:27:42 2010 -0500
+++ b/runtimec/src/fivmr_sysdep.h	Thu Mar 04 20:52:23 2010 -0500
@@ -302,6 +302,7 @@
 
 typedef uint64_t fivmr_Nanos;
 
+fivmr_Nanos fivmr_nanosResolution();
 fivmr_Nanos fivmr_curTime(void);
 
 static inline fivmr_Nanos fivmr_curTimeLogging(int level) {
diff -r 7e2669befe7e runtimec/src/fivmr_typedata.c
--- a/runtimec/src/fivmr_typedata.c	Thu Feb 25 19:27:42 2010 -0500
+++ b/runtimec/src/fivmr_typedata.c	Thu Mar 04 20:52:23 2010 -0500
@@ -147,6 +147,14 @@
 		    }
 		}
 		if (!ts->curException) {
+                    fivmr_MemoryArea *currentArea;
+                    if (FIVMR_SCOPED_MEMORY(&ts->vm->settings)) {
+                        currentArea=ts->gc.currentArea;
+                        if(currentArea!=ts->gc.baseStackEntry.area) {
+                            fivmr_MemoryArea_setCurrentArea(
+                                ts, ts->gc.baseStackEntry.area);
+                        }
+                    }
 		    clinit=fivmr_TypeData_findStaticMethod(ts->vm,td,"<clinit>","()V");
 		    if (clinit==NULL) {
 			/* awesome, nothing to do. */
@@ -171,6 +179,11 @@
 			    LOG(8,("%s returned.",fivmr_MethodRec_describe(clinit)));
 			}
 		    }
+                    if (FIVMR_SCOPED_MEMORY(&ts->vm->settings)) {
+                        if (currentArea!=ts->gc.baseStackEntry.area) {
+                            fivmr_MemoryArea_setCurrentArea(ts, currentArea);
+                        }
+                    }
 		}
 	    }
 	    fivmr_fence();
diff -r 7e2669befe7e runtimej/src/com/fiji/fivm/r1/MM.java
--- a/runtimej/src/com/fiji/fivm/r1/MM.java	Thu Feb 25 19:27:42 2010 -0500
+++ b/runtimej/src/com/fiji/fivm/r1/MM.java	Thu Mar 04 20:52:23 2010 -0500
@@ -78,6 +78,20 @@
         return 1;
     }
     
+    @NoPollcheck
+    @NoSafepoint
+    @Inline
+    public static boolean inOuterArea(int allocSpace) {
+	if (allocSpace != objectSpace()) {
+	    return false;
+	}
+	return (CType.getPointer(getGCData(),"fivmr_GCData","currentArea")
+		==CType.getPointer(getGCData()
+				   .add(CType.offsetof("fivmr_GCData",
+						       "baseStackEntry")),
+				   "fivmr_MemoryAreaStack", "area"));
+    }
+
     /**
      * Returns the offset from the TypeData pointer to where the object points. 
      * @return the offset from the TypeData pointer to where the object points.
@@ -345,6 +359,11 @@
                             Pointer object) {
         if (gcSpace==stackAllocSpace()) {
             gcHeader(object).store(frame.ushr(2));
+	} else if (Settings.SCOPED_MEMORY&&!inOuterArea(gcSpace)) {
+	    gcHeader(object).store(CType.getPointer(CType.getPointer(
+		getGCData(),"fivmr_GCData","currentArea"),
+						    "fivmr_MemoryArea",
+						    "scopeID").ushr(2));
         } else {
             if (Settings.NOGC) {
                 gcHeader(object).store(Pointer.fromIntSignExtend(-1));
@@ -772,6 +791,10 @@
         if (Settings.PROFILE_GC) {
             fivmr_SPC_incAllocSlowPath();
         }
+	if (Settings.SCOPED_MEMORY && allocSpace == objectSpace()
+	    && !inOuterArea(allocSpace)) {
+	    throwOOME();
+	}
         
         Pointer size=
             alignRaw(Pointer.fromInt(fivmr_TypeData_size(td)),
@@ -834,6 +857,10 @@
         if (Settings.PROFILE_GC) {
             fivmr_SPC_incAllocSlowPath();
         }
+	if (Settings.SCOPED_MEMORY && allocSpace == objectSpace()
+	    && !inOuterArea(allocSpace)) {
+	    throwOOME();
+	}
         
 	if (allocSpace == stackAllocSpace() ||
 	    CType.getBoolean(getGC(),"fivmr_GC","noMoreHeapAlloc")) {
@@ -856,6 +883,11 @@
                                              int numEle,
                                              Pointer eleSize,
                                              Pointer payloadSize) {
+	if (Settings.SCOPED_MEMORY && allocSpace == objectSpace()
+	    && !inOuterArea(allocSpace)) {
+	    throwOOME();
+	}
+
         Pointer unalignedSize=computeArraySizeWithPayloadSize(allocSpace,payloadSize,eleSize);
         Pointer size=alignCoeff(unalignedSize,
                                 requiredSizeAlignment(),
@@ -1088,6 +1120,9 @@
                 ?CType.getPointer(alloc,"fivmr_GCSpaceAlloc","zero")
                 :CType.getPointer(alloc,"fivmr_GCSpaceAlloc","size"))) {
             Magic.unlikely();
+	    if (Settings.SCOPED_MEMORY&&!inOuterArea(allocSpace)) {
+		throwOOME();
+	    }
             if (Settings.INTERNAL_INST) {
                 FIVMR_II_BEFORE_ALLOC_SLOW(Magic.curThreadState(),
                                            Magic.curFrame(),
@@ -1295,6 +1330,9 @@
                     ?CType.getPointer(alloc,"fivmr_GCSpaceAlloc","zero")
                     :CType.getPointer(alloc,"fivmr_GCSpaceAlloc","size"))) {
                 Magic.unlikely();
+		if (Settings.SCOPED_MEMORY&&!inOuterArea(allocSpace)) {
+		    throwOOME();
+		}
                 if (Settings.INTERNAL_INST && !Settings.HFGC_ALL_ARRAYLETS) {
                     FIVMR_II_BEFORE_ALLOC_ARRAY_SLOW(Magic.curThreadState(),
                                                      Magic.curFrame(),
diff -r 7e2669befe7e runtimej/src/edu/purdue/scj/BackingStoreID.java
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/runtimej/src/edu/purdue/scj/BackingStoreID.java	Thu Mar 04 20:52:23 2010 -0500
@@ -0,0 +1,102 @@
+package edu.purdue.scj;
+
+import com.fiji.fivm.r1.Pointer;
+import com.fiji.fivm.r1.CType;
+import com.fiji.fivm.r1.Magic;
+
+import com.fiji.fivm.r1.RuntimeImport;
+import com.fiji.fivm.r1.NoScopeChecks;
+
+import javax.realtime.IllegalAssignmentError;
+
+public class BackingStoreID {
+    private Pointer area = Pointer.zero();
+    private Object note = null;
+    private Object portal = null;
+    private int threadSpecific = 0;
+    private final String name;
+
+    public BackingStoreID(String name) {
+	this.name = name;
+    }
+
+    public String getName() {
+	return name;
+    }
+
+    public void setThreadSpecific(int areaid) {
+	threadSpecific = areaid;
+    }
+
+    public Object getNote() {
+	return note;
+    }
+
+    public void setNote(Object note) {
+	this.note = note;
+    }
+
+    public Object getPortal() {
+	return portal;
+    }
+
+    @NoScopeChecks
+    public void setPortal(Object portal) {
+	if (VMSupport.areaOf(portal) != this || getArea() == Pointer.zero()) {
+	    throw new IllegalAssignmentError();
+	}
+	this.portal = portal;
+    }
+
+    public void setArea(Pointer area) {
+	this.area = area;
+    }
+
+    public Pointer getArea() {
+	if (threadSpecific != 0) {
+	    return fivmr_MemoryArea_getThreadSpecific(Magic.curThreadState(),
+						      threadSpecific);
+	} else {
+	    return area;
+	}
+    }
+
+    public long getSize() {
+	if (getArea() == Pointer.zero()) {
+	    return 0;
+	}
+	return CType.getPointer(getArea(), "fivmr_MemoryArea", "totalsize").asLong();
+    }
+
+    public long getConsumed() {
+	if (isCurrent()) {
+	    /* NB: This requires that alloc[0] is the space allocator
+	     * information, and that it is the first element in GCData;
+	     * MM currently also assumes this */
+	    return CType.getPointer(Magic.curThreadState().add(
+					CType.offsetof("fivmr_ThreadState",
+						       "gc")),
+				    "fivmr_GCSpaceAlloc", "bump").sub(
+		CType.getPointer(Magic.curThreadState().add(
+				     CType.offsetof("fivmr_ThreadState", "gc")),
+				 "fivmr_GCSpaceAlloc", "start")).asLong();
+	} else {
+	    return CType.getPointer(getArea(), "fivmr_MemoryArea", "bump").sub(
+		CType.getPointer(getArea(), "fivmr_MemoryArea", "start")).asLong();
+	}
+    }
+
+    public long getRemaining() {
+	return getSize() - getConsumed();
+    }
+
+    private boolean isCurrent() {
+	return getArea() == CType.getPointer(Magic.curThreadState().add(
+	    CType.offsetof("fivmr_ThreadState", "gc")),
+					     "fivmr_GCData", "currentArea");
+    }
+
+    @RuntimeImport
+    static native Pointer fivmr_MemoryArea_getThreadSpecific(Pointer ts,
+							     int areaid);
+}
diff -r 7e2669befe7e runtimej/src/edu/purdue/scj/VMSupport.java
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/runtimej/src/edu/purdue/scj/VMSupport.java	Thu Mar 04 20:52:23 2010 -0500
@@ -0,0 +1,273 @@
+package edu.purdue.scj;
+
+import com.fiji.fivm.ThreadPriority;
+import com.fiji.fivm.Time;
+import com.fiji.fivm.r1.fivmRuntime;
+import com.fiji.fivm.r1.MM;
+import com.fiji.fivm.r1.Pointer;
+import com.fiji.fivm.r1.CType;
+import com.fiji.fivm.r1.CVar;
+import com.fiji.fivm.r1.Magic;
+import com.fiji.fivm.r1.NoSafepoint;
+import com.fiji.fivm.r1.Export;
+import com.fiji.fivm.r1.RuntimeImport;
+import com.fiji.fivm.r1.Import;
+import com.fiji.fivm.r1.GodGiven;
+import com.fiji.fivm.r1.NoNativeFrame;
+import com.fiji.fivm.r1.NoExecStatusTransition;
+import com.fiji.fivm.r1.UseObjectsNotHandles;
+
+import java.lang.fivmSupport;
+
+import javax.safetycritical.ThrowBoundaryError;
+
+public class VMSupport {
+    private static BackingStoreID immortalStoreID =
+	new BackingStoreID("Immortal");
+    private static BackingStoreID heapStoreID = new BackingStoreID("Heap");
+    private static BackingStoreID stackStoreID = new BackingStoreID("Stack");
+
+    static {
+	immortalStoreID.setThreadSpecific(
+	    CVar.getInt("FIVMR_MEMORYAREA_IMMORTAL"));
+	heapStoreID.setThreadSpecific(CVar.getInt("FIVMR_MEMORYAREA_HEAP"));
+	stackStoreID.setArea(fivmr_MemoryArea_getStackArea());
+	CType.put(fivmr_MemoryArea_getStackArea(),
+		  "fivmr_MemoryArea", "bsid",
+		  Pointer.fromObject(stackStoreID));
+    }
+
+    public static void enter(BackingStoreID store, Runnable logic) {
+	fivmr_MemoryArea_enter(Magic.curThreadState(),
+			       store.getArea(), logic);
+    }
+
+    public static BackingStoreID pushScope(long size) {
+	BackingStoreID bsid = new BackingStoreID("Private");
+	Magic.fence();
+	Pointer area = fivmr_MemoryArea_push(Magic.curThreadState(),
+					     size, bsid);
+	Magic.fence();
+	bsid.setArea(area);
+	return bsid;
+    }
+
+    public static BackingStoreID popScope() {
+	Magic.fence();
+	BackingStoreID bsid = fivmr_MemoryArea_pop(Magic.curThreadState());
+	Magic.fence();
+	return bsid;
+    }
+
+    public static Object getNote(BackingStoreID scope) {
+	return scope.getNote();
+    }
+
+    public static void setNote(BackingStoreID scope, Object note) {
+	scope.setNote(note);
+    }
+
+    /** Get the portal associated with the scope */
+    public static Object getPortal(BackingStoreID bsid) {
+	return bsid.getPortal();
+    }
+
+    /** Set the portal associated with the scope */
+    public static void setPortal(BackingStoreID bsid, Object portal) {
+	bsid.setPortal(portal);
+    }
+
+    public static BackingStoreID setCurrentArea(BackingStoreID scope) {
+	Pointer area = fivmr_MemoryArea_setCurrentArea(Magic.curThreadState(),
+						       scope.getArea());
+	return (BackingStoreID)fivmr_MemoryArea_getBSID(area);
+    }
+
+    public static BackingStoreID getCurrentArea() {
+	return (BackingStoreID) fivmr_MemoryArea_getBSID(
+	     CType.getPointer(Magic.curThreadState().add(
+		CType.offsetof("fivmr_ThreadState", "gc")),
+			      "fivmr_GCData", "currentArea"));
+    }
+
+    public static BackingStoreID getImmortalArea() {
+	return immortalStoreID;
+    }
+
+    /* NB: This depends critically on the layout of fivmr_ScopeID. */
+    public static BackingStoreID areaOf(Object ref) {
+	Pointer pscopeID = Pointer.fromObject(ref).sub(
+	    MM.objectGCOffset()).loadPointer();
+	Pointer mask = Pointer.fromInt(0x3).shl(Pointer.size()*8 - 2);
+	if (mask == pscopeID.and(mask)) {
+	    return immortalStoreID;
+	} else if (pscopeID.and(mask) != Pointer.zero()) {
+	    return heapStoreID;
+	} else {
+	    /* We don't need getBSID here because we know this is not
+	     * thread-specific */
+	    Pointer scopeID = pscopeID.shl(2).loadPointer();
+	    if (scopeID.and(Pointer.fromInt(0x1)) == Pointer.zero()) {
+		return stackStoreID;
+	    } else {
+		return (BackingStoreID)CType.getPointer(scopeID.xor(
+		        Pointer.fromInt(0x1)),
+		    "fivmr_MemoryArea", "bsid").asObject();
+	    }
+	}
+    }
+
+    public static long getScopeSize(BackingStoreID scope) {
+	return scope.getSize();
+    }
+
+    public static long memoryConsumed(BackingStoreID scope) {
+	return scope.getConsumed();
+    }
+
+    public static long memoryRemaining(BackingStoreID scope) {
+	return scope.getRemaining();
+    }
+
+    public static int getMinRTPriority() {
+	return ThreadPriority.FIFO | ThreadPriority.FIFO_MIN;
+    }
+
+    public static int getMaxRTPriority() {
+	return ThreadPriority.FIFO | ThreadPriority.FIFO_MAX;
+    }
+
+    public static int delayCurrentThreadAbsolute(long nanos) {
+	try {
+	    fivmRuntime.sleepAbsolute(nanos);
+	} catch (InterruptedException e) {
+	    return -1;
+	}
+	return 0;
+    }
+
+    /* FIXME */
+    public static void setTotalBackingStore(Thread t, long size) {
+    }
+
+    public static long getCurrentTime() {
+	return Time.nanoTime();
+    }
+
+    public static long getClockResolution() {
+	return fivmr_nanosResolution();
+    }
+
+    /* FIXME: Does not appear to be correct for HFGC ... we probably
+     * don't care right now, either. */
+    public static long sizeOf(Class<?> clazz) {
+	Pointer td = fivmSupport.typeDataFromClass(clazz);
+	return alignSize(fivmRuntime.fivmr_TypeData_size(td),
+			 fivmRuntime.fivmr_TypeData_requiredAlignment(td));
+    }
+
+    /* FIXME */
+    public static long sizeOfReferenceArray(int length) {
+	Pointer td = fivmSupport.typeDataFromClass(Object.class);
+	int size = fivmRuntime.fivmr_TypeData_refSize(td);
+	return MM.totalHeaderSize() + 4
+	    + alignSize(size, Pointer.size()) * length;
+    }
+
+    /* FIXME */
+    public static long sizeOfPrimitiveArray(int length, Class<?> clazz) {
+	int size;
+	if (clazz == Byte.class || clazz == Boolean.class) {
+	    size = 1;
+	} else if (clazz == Character.class || clazz == Short.class) {
+	    size = 2;
+	} else if (clazz == Integer.class || clazz == Float.class
+		   || clazz == Enum.class) {
+	    size = 4;
+	} else if (clazz == Long.class || clazz == Double.class) {
+	    size = 8;
+	} else {
+	    throw new IllegalArgumentException("type is not primitive");
+	}
+	return alignSize(MM.totalHeaderSize() + 4 + size * length,
+			 (size <= 4) ? 4 : 8);
+    }
+
+    private static int alignSize(int size, int align) {
+	return ((size+align-1) & ~(align-1));
+    }
+
+    @SuppressWarnings("unused")
+    @Export
+    @UseObjectsNotHandles
+    @NoExecStatusTransition
+    private static void fivmr_MemoryArea_doRun(BackingStoreID bsid, Runnable logic)
+	throws Throwable {
+	try {
+	    logic.run();
+	} catch (Throwable e) {
+	    if (VMSupport.areaOf(e) == bsid) {
+		fivmr_MemoryArea_setCurrentArea(Magic.curThreadState(),
+						CType.getPointer(bsid.getArea(),
+								 "fivmr_MemoryArea",
+								 "parent"));
+		throw new ThrowBoundaryError();
+	    } else {
+		throw e;
+	    }
+	}
+    }
+
+    @Export
+    @UseObjectsNotHandles
+    @NoExecStatusTransition
+    private static Object fivmr_MemoryArea_getBSID(Pointer area) {
+	if (area == fivmr_MemoryArea_getImmortalArea(Magic.curThreadState())) {
+	    return immortalStoreID;
+	} else if (area == fivmr_MemoryArea_getHeapArea(Magic.curThreadState())) {
+	    return heapStoreID;
+	} else {
+	    return CType.getPointer(area, "fivmr_MemoryArea",
+				    "bsid").asObject();
+	}
+    }
+
+    @RuntimeImport
+    @NoSafepoint
+    private static native Pointer fivmr_MemoryArea_push(Pointer ts,
+							long size,
+							BackingStoreID bsid);
+
+    @RuntimeImport
+    @NoSafepoint
+    private static native BackingStoreID fivmr_MemoryArea_pop(Pointer ts);
+
+    @Import
+    @GodGiven
+    @UseObjectsNotHandles
+    @NoExecStatusTransition
+    @NoNativeFrame
+    private static native void fivmr_MemoryArea_enter(Pointer ts,
+						      Pointer area,
+						      Runnable logic);
+
+    @RuntimeImport
+    @NoSafepoint
+    private static native Pointer fivmr_MemoryArea_setCurrentArea(
+	Pointer ts,
+	Pointer area);
+
+    @RuntimeImport
+    private static native Pointer fivmr_MemoryArea_getImmortalArea(
+	Pointer ts);
+
+    @RuntimeImport
+    private static native Pointer fivmr_MemoryArea_getHeapArea(
+	Pointer ts);
+
+    @RuntimeImport
+    private static native Pointer fivmr_MemoryArea_getStackArea();
+
+    @RuntimeImport
+    private static native long fivmr_nanosResolution();
+}
diff -r 7e2669befe7e test/src/com/fiji/fivm/test/RawScopedMemoryTest.java
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/test/src/com/fiji/fivm/test/RawScopedMemoryTest.java	Thu Mar 04 20:52:23 2010 -0500
@@ -0,0 +1,444 @@
+package com.fiji.fivm.test;
+
+import com.fiji.fivm.Settings;
+import com.fiji.fivm.r1.NoInline;
+import com.fiji.fivm.r1.NoScopeChecks;
+
+import edu.purdue.scj.VMSupport;
+import edu.purdue.scj.BackingStoreID;
+
+import javax.realtime.IllegalAssignmentError;
+import javax.safetycritical.ThrowBoundaryError;
+
+class RawScopedMemoryTest {
+    private static final BackingStoreID outer = VMSupport.getCurrentArea();
+    private static final int scopeSize = 40960;
+
+    private static class StaticRunnable implements Runnable {
+	static BackingStoreID outer;
+	static StringBuffer sb;
+
+	static {
+	    sb = new StringBuffer();
+	}
+
+	public StaticRunnable(BackingStoreID outer) {
+	    this.outer = outer;
+	}
+
+	public void run() {
+    	    message("Running static runnable");
+    	    if (VMSupport.areaOf(sb) != outer) {
+    		throw new Fail("Static Object not allocated in outer area");
+    	    }
+    	}
+    }
+
+    private static class DepthCheck implements Runnable {
+    	final BackingStoreID parent;
+    	final BackingStoreID mine;
+    	final int depth;
+    	final int total;
+
+    	public DepthCheck(int depth, BackingStoreID parent,
+    			  BackingStoreID mine) {
+    	    this(depth, depth, parent, mine);
+    	}
+
+    	public DepthCheck(int total, int depth, BackingStoreID parent,
+    			  BackingStoreID mine) {
+    	    this.parent = parent;
+    	    this.mine = mine;
+    	    this.depth = depth;
+    	    this.total = total;
+    	}
+
+    	public void run() {
+    	    StringBuffer sb = new StringBuffer();
+    	    BackingStoreID current = VMSupport.areaOf(sb);
+    	    if (current == parent) {
+    		throw new Fail("child scope backing store ("
+    			       + current + ") matches parent ("
+    			       + parent + ") at depth " + depth);
+    	    }
+	    if (current != mine) {
+		throw new Fail("backing store (" + current
+			       + ") does not match declared ("
+			       + mine + ") at depth " + depth);
+	    }
+	    if (depth == 0)
+		return;
+	    BackingStoreID bsid = VMSupport.pushScope(scopeSize);
+	    if (bsid == mine) {
+		throw new Fail("newly created backing store ("
+			       + bsid + ") matches current ("
+			       + mine + ") at depth " + depth);
+	    }
+	    DepthCheck next = new DepthCheck(total, depth - 1, mine, bsid);
+	    VMSupport.enter(bsid, next);
+	    VMSupport.popScope();
+	}
+    }
+
+    private static class PredictableSize {
+	public int i;
+	public double d;
+	public boolean b;
+
+	PredictableSize(int i, double d, boolean b) {
+	    this.i = i;
+	    this.d = d;
+	    this.b = b;
+	}
+    }
+
+    public static void message(String message) {
+	BackingStoreID bsid = VMSupport.setCurrentArea(outer);
+	System.out.println(message);
+	VMSupport.setCurrentArea(bsid);
+    }
+
+    public static void main(String[] args) {
+	if (Settings.NOGC) {
+	    if (outer != VMSupport.getImmortalArea()) {
+		throw new Fail("Not running in immortal area");
+	    }
+	} else {
+	    if (outer == VMSupport.getImmortalArea()) {
+		throw new Fail("Heap execution in immortal area");
+	    }
+	}
+
+	final BackingStoreID bsid = VMSupport.pushScope(scopeSize);
+	if (VMSupport.areaOf(bsid) != outer) {
+	    throw new Fail("Object created in unpredictable area");
+	}
+
+	// If we cannot setCurrentArea, we cannot use message() ... check
+	// this first.
+	VMSupport.enter(bsid, new Runnable() {
+		public void run() {
+		    BackingStoreID inner = VMSupport.getCurrentArea();
+		    if (inner != bsid) {
+			throw new Fail("Inner area does not equal declared area");
+		    }
+		    if (VMSupport.setCurrentArea(outer) != inner) {
+			throw new Fail("setCurrentArea returned incorrect BackingStoreID");
+		    }
+		    StringBuffer sb = new StringBuffer();
+		    if (VMSupport.areaOf(sb) != outer
+			|| VMSupport.getCurrentArea() != outer) {
+			throw new Fail("setCurrentArea failed");
+		    }
+		    System.out.println("VMSupport.setCurrentArea() seems to work");
+		}
+	    });
+
+	VMSupport.enter(bsid, new Runnable() {
+		public void run() {
+		    message("Running anonymous runnable");
+		    BackingStoreID inner = VMSupport.getCurrentArea();
+		    if (inner == outer) {
+			throw new Fail("Private memory allocation occurred in global memory");
+		    }
+		    if (inner != bsid) {
+			throw new Fail("Inner area does not equal declared area");
+		    }
+		    StaticRunnable sr = new StaticRunnable(outer);
+		    if (VMSupport.areaOf(sr) != inner) {
+			throw new Fail("Inner allocation not in inner area");
+		    }
+		    sr.run();
+		}
+	    });
+
+	message("Running nested area check");
+	DepthCheck dc = new DepthCheck(3, outer, bsid);
+	VMSupport.enter(bsid, dc);
+
+	message("Trying to throw a legal exception from inside a scope");
+
+	try {
+	    final RuntimeException e = new RuntimeException();
+	    VMSupport.enter(bsid, new Runnable() {
+		    public void run() {
+			message("Throwing RuntimeException");
+			throw e;
+		    }
+		});
+	} catch (RuntimeException e) {
+	    message("Caught exception");
+	}
+
+	message("Trying to throw an illegal exception from inside a scope");
+
+	boolean caught = false;
+	try {
+	    VMSupport.enter(bsid, new Runnable() {
+		    public void run() {
+			message("Throwing RuntimeException");
+			throw new RuntimeException();
+		    }
+		});
+	} catch (ThrowBoundaryError e) {
+	    caught = true;
+	    message("Caught exception as ThrowBoundaryError");
+	}
+	if (!caught) {
+	    throw new Fail("Did not generate ThrowBoundaryError");
+	}
+
+	message("Trying illegal assignment");
+	VMSupport.enter(bsid, new Runnable() {
+		public void run() {
+		    BackingStoreID bsid2 = VMSupport.pushScope(scopeSize);
+		    final Object[] a1 = new Object[2];
+		    final StringBuffer sb1 = new StringBuffer();
+		    a1[0] = sb1;
+		    VMSupport.enter(bsid2, new Runnable() {
+			    public void run() {
+				Object[] a2 = new Object[2];
+				StringBuffer sb2 = new StringBuffer();
+				boolean caught = false;
+				a2[0] = sb1;
+				a2[1] = sb2;
+				if (VMSupport.areaOf(a1) == VMSupport.areaOf(sb2)) {
+				    throw new Fail("Objects are in the same scope");
+				}
+				try {
+				    a1[1] = sb2;
+				} catch (IllegalAssignmentError e) {
+				    caught = true;
+				    message("Caught illegal assignment");
+				}
+				if (!caught) {
+				    VMSupport.setCurrentArea(outer);
+				    throw new Fail("Failed to catch illegal assignment");
+				}
+			    }
+			});
+		    VMSupport.popScope();
+		}
+	    });
+
+	message("Trying illegal assignment with @NoScopeChecks");
+	VMSupport.enter(bsid, new Runnable() {
+		public void run() {
+		    BackingStoreID bsid2 = VMSupport.pushScope(scopeSize);
+		    final Object[] a1 = new Object[2];
+		    final StringBuffer sb1 = new StringBuffer();
+		    a1[0] = sb1;
+		    VMSupport.enter(bsid2, new Runnable() {
+			    @NoScopeChecks
+			    public void run() {
+				Object[] a2 = new Object[2];
+				StringBuffer sb2 = new StringBuffer();
+				boolean caught = false;
+				a2[0] = sb1;
+				a2[1] = sb2;
+				if (VMSupport.areaOf(a1) == VMSupport.areaOf(sb2)) {
+				    throw new Fail("Objects are in the same scope");
+				}
+				try {
+				    a1[1] = sb2;
+				} catch (IllegalAssignmentError e) {
+				    VMSupport.setCurrentArea(outer);
+				    throw new Fail("IllegalAssignmentError was raised");				}
+			    }
+			});
+		    VMSupport.popScope();
+		}
+	    });
+
+	message("Setting a legal portal");
+	VMSupport.enter(bsid, new Runnable() {
+		public void run() {
+		    Object o = new Object();
+		    if (VMSupport.areaOf(o) != bsid) {
+			throw new Fail("Object allocated in incorrect area");
+		    }
+		    VMSupport.setPortal(bsid, o);
+		}
+	    });
+
+	message("Setting an illegal portal");
+	try {
+	    Object o = new Object();
+	    if (VMSupport.areaOf(o) == bsid) {
+		throw new Fail("Object allocated in incorrect area");
+	    }
+	    VMSupport.setPortal(bsid, o);
+	} catch (IllegalAssignmentError e) {
+	    caught = true;
+	}
+	if (!caught) {
+	    throw new Fail("setPortal accepted invalid assignment");
+	}
+
+	message("Trying legal return");
+	VMSupport.enter(bsid, new Runnable() {
+		public void run() {
+		    BackingStoreID bsid2 = VMSupport.pushScope(scopeSize);
+		    VMSupport.enter(bsid2, new Runnable() {
+			    @NoInline
+			    public Object allocObject() {
+				return new Object[1];
+			    }
+
+			    public void run() {
+				Object a[] = new Object[1];
+				VMSupport.setCurrentArea(bsid);
+				a[0] = allocObject();
+			    }
+			});
+		    VMSupport.popScope();
+		}
+	    });
+
+	message("Trying illegal return");
+	VMSupport.enter(bsid, new Runnable() {
+		@NoInline
+		public Object allocObject() {
+		    return new Object[1];
+		}
+
+		public void run() {
+		    VMSupport.setCurrentArea(outer);
+		    Object[] a = new Object[1];
+		    VMSupport.setCurrentArea(bsid);
+		    boolean caught = false;
+		    try {
+			a[0] = allocObject();
+		    } catch (IllegalAssignmentError e) {
+			caught = true;
+			message("Caught illegal return");
+		    }
+		    if (!caught) {
+			VMSupport.setCurrentArea(outer);
+			throw new Fail("Failed to catch illegal return");
+		    }
+		}
+	    });
+
+	message("Triggering OOME");
+	VMSupport.enter(bsid, new Runnable() {
+		public void run() {
+		    boolean caught = false;
+		    try {
+			Object[] a = new Object[scopeSize];
+		    } catch (OutOfMemoryError e) {
+			caught = true;
+			message("Caught OOME");
+		    }
+		    if (!caught) {
+			VMSupport.setCurrentArea(outer);
+			throw new Fail("OOME was not generated");
+		    }
+		}
+	    });
+
+	message("Checking scope size and available memory");
+	VMSupport.enter(bsid, new Runnable() {
+		@NoInline
+		public void allocCheck() {
+		    Object[] a = new Object[1];
+		    if (VMSupport.memoryRemaining(bsid) == scopeSize
+			|| VMSupport.memoryConsumed(bsid) == 0) {
+			VMSupport.setCurrentArea(outer);
+			throw new Fail("Scope memory not consumed by alloc");
+		    }
+		}
+		public void run() {
+		    if (VMSupport.getScopeSize(bsid) != scopeSize) {
+			VMSupport.setCurrentArea(outer);
+			throw new Fail("Scope size is incorrect: "
+				       + VMSupport.getScopeSize(bsid));
+		    }
+		    if (VMSupport.memoryConsumed(bsid) != 0) {
+			VMSupport.setCurrentArea(outer);
+			throw new Fail("Scope memory consumed is incorrect: "
+				       + VMSupport.memoryConsumed(bsid));
+		    }
+		    if (VMSupport.memoryRemaining(bsid) != scopeSize) {
+			VMSupport.setCurrentArea(outer);
+			throw new Fail("Scope memory remaning is incorrect: "
+				       + VMSupport.memoryRemaining(bsid));
+		    }
+		    allocCheck();
+		}
+	    });
+
+	if (!Settings.HFGC) {
+	    message("Verifying allocation sizes");
+	    VMSupport.enter(bsid, new Runnable() {
+		    public void run() {
+			PredictableSize ps = new PredictableSize(1, 1.0, true);
+			if (VMSupport.memoryConsumed(bsid)
+			    > VMSupport.sizeOf(PredictableSize.class)) {
+			    VMSupport.setCurrentArea(outer);
+			    throw new Fail("Estimated size less than allocated for PredictableSize");
+			}
+		    }
+		});
+	    VMSupport.enter(bsid, new Runnable() {
+		    public void run() {
+			Object[] a = new Object[13];
+			if (VMSupport.memoryConsumed(bsid)
+			    > VMSupport.sizeOfReferenceArray(13)) {
+			    VMSupport.setCurrentArea(outer);
+			    throw new Fail("Estimated size less than allocated for ref array");
+			}
+		    }
+		});
+	    /* FIXME: We should test all of the primitive types here */
+	    VMSupport.enter(bsid, new Runnable() {
+		    public void run() {
+			byte[] a = new byte[13];
+			if (VMSupport.memoryConsumed(bsid)
+			    > VMSupport.sizeOfPrimitiveArray(13, Byte.class)) {
+			    VMSupport.setCurrentArea(outer);
+			    throw new Fail("Estimated size less than allocated for byte array");
+			}
+		    }
+		});
+	    VMSupport.enter(bsid, new Runnable() {
+		    public void run() {
+			short[] a = new short[13];
+			if (VMSupport.memoryConsumed(bsid)
+			    > VMSupport.sizeOfPrimitiveArray(13, Short.class)) {
+			    VMSupport.setCurrentArea(outer);
+			    throw new Fail("Estimated size less than allocated for short array");
+			}
+		    }
+		});
+	    VMSupport.enter(bsid, new Runnable() {
+		    public void run() {
+			int[] a = new int[13];
+			if (VMSupport.memoryConsumed(bsid)
+			    > VMSupport.sizeOfPrimitiveArray(13, Integer.class)) {
+			    VMSupport.setCurrentArea(outer);
+			    throw new Fail("Estimated size less than allocated for integer array");
+			}
+		    }
+		});
+	    VMSupport.enter(bsid, new Runnable() {
+		    public void run() {
+			double[] a = new double[13];
+			if (VMSupport.memoryConsumed(bsid)
+			    > VMSupport.sizeOfPrimitiveArray(13, Double.class)) {
+			    VMSupport.setCurrentArea(outer);
+			    throw new Fail("Estimated size less than allocated for Double array");
+			}
+		    }
+		});
+	}
+
+	BackingStoreID oldbsid = VMSupport.popScope();
+
+	if (oldbsid != bsid) {
+	    throw new Fail("Popped a different memory area than pushed");
+	}
+
+	message("Scoped memory interface seems to work");
+    }
+}
