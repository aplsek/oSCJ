package s3.services.simplejit;

import ovm.util.ArrayList;
import ovm.util.ByteBuffer;
import ovm.util.HTString2int;
import s3.services.simplejit.CodeLinker.RelativeJump;

/**
 * Responsible for patching native code generated by the compiler in connection
 * with relative/absolute branch offsets and function calls.
 * 
 * @author Hiroshi Yamauchi
 */
public abstract class CodeLinker {
    private ArrayList relativeJumps;

    private int[] bytecodePC2NativePC;

    public CodeLinker(int[] bytecodePC2NativePC) {
        this.relativeJumps = new ArrayList();
        this.bytecodePC2NativePC = bytecodePC2NativePC;
    }

    protected abstract RelativeJump makeRelativeJump(int branchPC,
						     int shift, int bits,
						     int targetBytecodePC);

    void registerRelativeJump(int branchPC, int targetBytecodePC) {
	registerRelativeJump(branchPC, 0, 32, targetBytecodePC);
    }

    public void registerRelativeJump(int branchPC,
                              int shift,
                              int bits,
                              int targetBytecodePC) {
        relativeJumps.add(makeRelativeJump(branchPC, shift, bits,
					   targetBytecodePC));
    }

    public void linkRelativeJumps(ByteBuffer code, int offset) {
        Object[] patchers = relativeJumps.toArray();
        for (int i = 0; i < patchers.length; i++) {
            ((RelativeJump) patchers[i]).patch(code,
					       bytecodePC2NativePC,
					       offset);
        }
    }

    protected abstract static class RelativeJump {
        protected int branchPC;
        protected int shift;
        protected int bits;
        protected int targetBytecodePC;

        public RelativeJump(int branchPC, int shift, int bits,
			    int targetBytecodePC) {
            this.branchPC = branchPC;
            this.shift = shift;
            this.bits = bits;
            this.targetBytecodePC = targetBytecodePC;
        }

        public abstract void patch(ByteBuffer code,
				   int[] bytecodePC2NativePC,
				   int offset);
    }
}