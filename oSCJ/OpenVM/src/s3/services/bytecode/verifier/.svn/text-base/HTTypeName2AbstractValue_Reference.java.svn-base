// This hashtable class is generated by TGen.
// Please do not modify this source.
// ClassName   : HTTypeName2AbstractValue_Reference
// FromType    : TypeName
// ToType      : AbstractValue.Reference
// Compare     : .equals
// Hash        : .hashCode()
// NotFound    : null
// Default size: 1024
// Synchronized: no
// Serializable: noSerializable
// Profiling   : no
package s3.services.bytecode.verifier;

import ovm.core.repository.TypeName;
import ovm.services.bytecode.analysis.AbstractValue;

/**
 * Hashtable generated by TGen.
 **/
final  class HTTypeName2AbstractValue_Reference {
    private int mask;
    private final static int DEFAULT_SIZE = 1024;
    private final Binding[] buckets;
    private static final AbstractValue.Reference NOTFOUND = null; 
     // profiling members omitted

    /**
     * Internal binding class. Stores a key, value, and a link
     * to the next binding in the chain.
     **/
    static private final class Binding {
	Binding link;
	TypeName key;
	AbstractValue.Reference value;
	Binding(Binding link, TypeName key, AbstractValue.Reference value) {
	    this.link = link;
	    this.key = key;
	    this.value = value;
	} 
    }

    /**
     * Public default constructor.
     **/
    public HTTypeName2AbstractValue_Reference() {
	this(DEFAULT_SIZE);
    }

    /**
     * Constructor that specifies a hint size.
     **/
    public HTTypeName2AbstractValue_Reference(int hint) {	    
        int size = 8;
        while ( size < hint ) size *= 2;
        mask = size-1;
	this.buckets = new Binding[size];
	 // profiling code omitted
	
    }

    /**
     * gets something from hashtable and will return NOTFOUND.
     * Does _not_ insert anything into the hashtable.
     **/
    public final AbstractValue.Reference get(TypeName key) {
	Binding p = getAtOffset(mask&key.hashCode(), key);
	return (p != null) ? p.value : NOTFOUND;
    }

    /**
     * Put something into the hashtable. Checks to see if
     * the key is already in the hashtable, and if so, updates
     * the value associated with the key.
     **/
    public final void put(TypeName key, AbstractValue.Reference value) {

	int offset = mask&key.hashCode();
	Binding p = getAtOffset(offset, key);
	if ( p == null ) {
	    putAtOffset(offset, key, value);
        }
	else {
	    p.value = value;
        }
    }

    /**
     * Put something into the hashtable only if it is absent.
     * This will _not_ update the value of the specified key.
     **/
    public final void putIfAbsent(TypeName key, AbstractValue.Reference value) {

	int offset = mask&key.hashCode();
	Binding p = getAtOffset(offset, key);
	if ( p == null )
	    putAtOffset(offset, key, value);
    }

    /**
     * Return all keys in this table.
     **/
    public TypeName[] keys() {
	int length = 0;
        for (int i = 0; i < buckets.length; i++) {
            Binding b = buckets[i];
            while (b != null) {
                length++;
                b = b.link;
        }   }
        TypeName[] keys = new TypeName[length];
        int index = 0;
        for (int i = 0; i < buckets.length; i++) {
            Binding b = buckets[i];
            while (b != null) {
                keys[index++] = b.key;
                b = b.link;
            }
        }
        return keys;
     }


    /**
     * Get something from the hashtable, and if not present, 
     * insert it.                                                
     **/
    public final AbstractValue.Reference getPut(TypeName key, 
	AbstractValue.Reference value) {

	int offset = mask&key.hashCode();
	Binding p = getAtOffset(offset, key);
	if ( p == null ) {
	    putAtOffset(offset, key, value);
	    return NOTFOUND;
	}
	 
	return p.value;
    }


    /**
     * Insert something into the hashtable, even if it creates a duplicate.
     **/ 
    public final  void forcePut(TypeName key,
					    AbstractValue.Reference value) {
	int offset = mask&key.hashCode();
	buckets[offset] = new Binding(buckets[offset], key, value);
    }



    /**
     * private function to get something at a specified offset.
     **/
    private final Binding getAtOffset(int offset, TypeName key) {
	 // profiling code omitted
	Binding p;

	for (p = buckets[offset]; p!= null; p = p.link) {
	     // profiling code omitted
	    if (key.equals(p.key)) break;
        }
	
	 // profiling code omitted
	 // profiling code omitted

	return p;
    }

    private final  void putAtOffset(int offset, 
					 TypeName key,
					 AbstractValue.Reference value) {
	if (getAtOffset(offset, key) == null) {
	     // profiling code omitted
	    buckets[offset] = new Binding(buckets[offset], key, value);
	
    }
}

} // End HTTypeName2AbstractValue_Reference

