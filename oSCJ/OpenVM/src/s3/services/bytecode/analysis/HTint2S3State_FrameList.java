/** 
 * This hashtable class is generated by TGen 2.0r.
 *
 * PLEASE DO NOT MODIFY THIS SOURCE.
 *
 * @author Ben L. Titzer
 * @author TGen2
 **/

// HashtableName : HTint2S3State_FrameList
// KeyType : int
// ValueType : S3State.FrameList
// Compare : ==
// HashFunction :
// NotFound : null
// Default size : 1024
// Synchronized : no
// Serializable : no
// Profiling : no

package s3.services.bytecode.analysis;

/**
 * This Hashtable is generated by TGen. Its key type is int and its value type
 * is S3State.FrameList.
 * @author Ben L. Titzer
 * @author Christian Grothoff
 * @author TGen2
 */
final public class HTint2S3State_FrameList extends ovm.core.OVMBase {
    // FIXME why not Integer.MIN_VALUE, and why not even the same value?
    public static final int MININT = -0x7fffffff;
    public static final S3State.FrameList NOTFOUND = null;

    private static final int DEFAULT_SIZE = 1024;

    private int mask;
    private int numElems_;
    private final Binding[] buckets;
    // profiling members

    /**
     * Internal binding class. Stores a key, value, and a link to the next
     * binding in the chain.
     */
    static private final class Binding extends ovm.core.OVMBase {
        Binding link;
        int key;
        S3State.FrameList value;
        Binding(Binding link, int key, S3State.FrameList value) {
            this.link = link;
            this.key = key;
            this.value = value;
        }
    }

    /**
     * Public default constructor.
     */
    public HTint2S3State_FrameList() {
        this(DEFAULT_SIZE);
    }

    /**
     * Constructor that specifies a hint size.
     */
    public HTint2S3State_FrameList(int hint) {
        int size = 8;
        while (size < hint)
            size *= 2;
        mask = size - 1;
        this.buckets = new Binding[size];
        // profiling code

    }

    /**
     * gets something from hashtable and will return NOTFOUND. Does _not_
     * insert anything into the hashtable.
     */
    public final S3State.FrameList get(int key) {
        Binding p = getAtOffset(mask & key, key);
        return (p != null) ? p.value : NOTFOUND;
    }

    /**
     * Put something into the hashtable. Checks to see if the key is already in
     * the hashtable, and if so, updates the value associated with the key.
     */
    public final void remove(int key) {

        int offset = mask & key;
        Binding prev = null;
        Binding pos = buckets[offset];
        while (pos != null) {
            if (key == (pos.key))
                break;
            prev = pos;
            pos = pos.link;
        }
        if (pos == null)
            return;
        if (prev == null)
            buckets[offset] = pos.link;
        else
            prev.link = pos.link;
    }

    /**
     * Put something into the hashtable. Checks to see if the key is already in
     * the hashtable, and if so, updates the value associated with the key.
     */
    public final void put(int key, S3State.FrameList value) {

        int offset = mask & key;
        Binding p = getAtOffset(offset, key);
        if (p == null) {
            putAtOffset(offset, key, value);
        } else {
            p.value = value;
        }
    }

    /**
     * Put something into the hashtable only if it is absent. This will _not_
     * update the value of the specified key.
     */
    public final void putIfAbsent(int key, S3State.FrameList value) {

        int offset = mask & key;
        Binding p = getAtOffset(offset, key);
        if (p == null)
            putAtOffset(offset, key, value);
    }

    /**
     * Return all keys in this table.
     */
    public int[] keys() {
        int length = 0;
        for (int i = 0; i < buckets.length; i++) {
            Binding b = buckets[i];
            while (b != null) {
                length++;
                b = b.link;
            }
        }
        int[] keys = new int[length];
        int index = 0;
        for (int i = 0; i < buckets.length; i++) {
            Binding b = buckets[i];
            while (b != null) {
                keys[index++] = b.key;
                b = b.link;
            }
        }
        return keys;
    }

    /**
     * Get something from the hashtable, and if not present, insert it.
     */
    public final S3State.FrameList getPut(int key, S3State.FrameList value) {

        int offset = mask & key;
        Binding p = getAtOffset(offset, key);
        if (p == null) {
            putAtOffset(offset, key, value);
            return NOTFOUND;
        }

        return p.value;
    }

    /**
     * Insert something into the hashtable, even if it creates a duplicate.
     */
    public final void forcePut(int key, S3State.FrameList value) {
        int offset = mask & key;
        buckets[offset] = new Binding(buckets[offset], key, value);
    }

    /**
     * Return the size (number of elements currently present) of the hashtable.
     */
    public final int size() {
        return numElems_;
    }

    /**
     * private function to get something at a specified offset.
     */
    private final Binding getAtOffset(int offset, int key) {
        // profiling code
        Binding p;

        for (p = buckets[offset]; p != null; p = p.link) {
            // profiling code
            if (key == (p.key))
                break;
        }

        // profiling code
        // profiling code

        return p;
    }

    private final void putAtOffset(
        int offset,
        int key,
        S3State.FrameList value) {
        if (getAtOffset(offset, key) == null) {
            // profiling code
            buckets[offset] = new Binding(buckets[offset], key, value);
            numElems_++;
        }
    }

} // End HTint2S3State_FrameList
