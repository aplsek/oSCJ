package s3.services.j2c;

import ovm.util.BitSet;
import ovm.util.ArrayList;
import ovm.util.HashMap;
import ovm.util.Iterator;

import s3.services.j2c.BBSpec.*;
import s3.services.j2c.J2cValue.*;
import ovm.core.repository.RepositoryUtils;
import ovm.core.repository.Selector;
import ovm.services.bytecode.SpecificationIR.AssignmentExp;

/**
 * Remove unneeded variables.  These unneeded variables include both
 * temporaries (with kind {@link s3.services.j2c.J2cValue#STACK_SLOT}
 * introduced for load and store instructions, and parameters of
 * inlined functions (which are often initialized from other local
 * variables).  Renaming descions are made using a standard copy
 * propagation analysis.<p>
 *
 * Copy propagation tells us when it is safe to replace a use of one
 * variable with the use of another, but it does not directly tell us
 * when alpha expansion is possible.  In particular, copy propagation
 * may tell us that a variable v1 may be replaced with v2 whenever v1
 * appears on the right-hand side of an Expr, but substituting v2 for
 * v1 may be unsafe if there are useless assignments to v1.<p>
 *
 * For this reason, we eliminate useless stores before we attempt
 * renaming.<p>
 *
 * Copy propagation involves two analyses.
 * {@link s3.services.j2c.CopyPropagation.DUChain}s must be computed
 * to examine all uses associated with a copy, and
 * {@link s3.services.j2c.CopyPropagation.AvailableCopies} are checked
 * at every use.  We compute DU chains at every
 * {@link s3.services.j2c.CopyPropagation.Copy}, and at every other
 * {@link s3.services.j2c.CopyPropagation.Def} that we may want to
 * eliminate as a useless store.<p>
 *
 * In addition, copy propagation does directly not tell us whether the
 * transative closure of a series of renames is safe.  As we rename
 * based on copy propagation, we update {@link #varUses} to record
 * additional dependencies.  See {@link #rename} for details.<p>
 *
 * There is not much more to tell.  Copy propagation make short work
 * of most inlined parameters and _stack variables generated by load
 * and store instructions.  In fact, it is probably far to heavy a
 * solution for this less general problems.
 * 
 * @author <a href="mailto://baker29@cs.purdue.edu"> Jason Baker </a>
 */
public class CopyPropagation {
    static final boolean VERBOSE = false;
    static final boolean STATS = false;

    boolean verbose;
    boolean stats;

    static class Use {
	BBSpec b;
	int idx;
	J2cValue var;

	Use next;
	int number;

	Use(BBSpec b, int idx, J2cValue var, Use next) {
	    this.b = b;
	    this.idx = idx;
	    this.var = var;
	    this.next = next;
	}
    }

    static class DU {
	BitSet gen;
	BitSet kill;
	BitSet in = new BitSet();
	DU(BitSet gen, BitSet kill) {
	    this.gen = gen;
	    this.kill = kill;
	}
    }

    static class Def extends DU {
	BBSpec b;
	int idx;

	Def(BitSet gen, BitSet kill, BBSpec b, int idx) {
	    super(gen, kill);
	    this.b = b;
	    this.idx = idx;
	}

	boolean present() {
	    return b.code[idx] != null;
	}

	J2cValue getLHS() {
	    return b.code[idx].dest;
	}
    }

    static class Copy extends Def implements Rename {
	int number;

	/**
	 * Suppose we have the sequence
	 * <code><pre>
	 *      v2 = v1    <i>C1</i>
	 *      v3 = v2    <i>C2</i>
	 * </pre></pre>
	 * And, when we look at C1, we deide that v2 can be renamed.
	 * Now, we consider C2.  We can only do so if both C1 and C2
	 * are available at each use of v3.  So, when we rename a
	 * variable based on copy propagation, we find all other
	 * copies involving that variable, and set rhsRename.
	 **/
	Copy rhsRename;
	
	J2cValue getRHS() {
	    IRExpr e = (IRExpr) b.code[idx];
	    return ((ValueAccessExp) e.source).v;
	}

	public void rename(LocalAllocator r) {
	    r.rename(getLHS(), getRHS());
	    b.code[idx] = null;
	}

	Copy(BitSet gen, BitSet kill, BBSpec b, int idx) {
	    super(gen, kill, b, idx);
	    this.b = b;
	    this.idx = idx;
	}
    }

    // FIXME unused
    static interface Rename {
	void rename(LocalAllocator r);
    }

    MethodCompiler mc;
    
    // All uses.  
    ArrayList uses = new ArrayList();

    // var -> set of uses
    BitSet[] varUses;
    
    // Expr -> Copy object
    HashMap copies = new HashMap();

    Copy[] copyArray;
    
    // var -> the set of copies it takes part in
    BitSet[] varCopies;

    // block, offset -> list of uses
    Use[][] exprUses;

    // # non-copy definitions that we track (we ignore stack-slot defs)
    int otherDefs;

    int makeUse(BBSpec b, int i, J2cValue v) {
	Use u = new Use(b, i, v, exprUses[b.number][i]);
	int idx = u.number = uses.size();
	uses.add(u);
	varUses[v.number].set(idx);
	exprUses[b.number][i] = u;
	return idx;
    }

    void dropExpr(BBSpec b, int i) {
	for (Use u = exprUses[b.number][i]; u != null; u = u.next)
	    varUses[u.var.number].clear(u.number);
	b.code[i] = null;
    }

    void addExprUses(BitSet set, BBSpec block, int i) {
	for (Use u = exprUses[block.number][i]; u != null; u = u.next)
	    set.set(u.number);
    }

    Def makeDef(BitSet gen, BitSet kill, BBSpec b, int i) {
	Def d = new Def(gen, kill, b, i);
	otherDefs++;
	return d;
    }

    Copy makeCopy(BitSet gen, BitSet kill, BBSpec b, int i) {
	Copy c = new Copy(gen, kill, b, i);
	c.number = copies.size();
	copies.put(b.code[i], c);
	varCopies[c.getLHS().number].set(c.number);
	varCopies[c.getRHS().number].set(c.number);
	return c;
    }

    public class UseAllocator extends ExprVisitor {
	BitSet uses;
	BBSpec b;
	int idx;

	public void visit(J2cValue v) {
	    if (!v.isConcrete() && v.name != null) {
		makeUse(b, idx, v);
	    } else {
		super.visit(v);
	    }
	}

	public void allocate(BBSpec b, int idx) {
	    if (b.code[idx] != null) {
		this.b = b;
		this.idx = idx;
		visitAppropriate(b.code[idx]);
	    }
	}
    }

    public static class EffectChecker extends ExprVisitor {
	boolean hasEffect;

	public void visit(InvocationExp e) {
	    hasEffect = true;
	}

	public void visit(AssignmentExp e) {
	    hasEffect = true;
	}

	// Return true if there are side effects in the given expression
	public boolean in(Expr e) {
	    hasEffect = false;
	    visitAppropriate(e);
	    return hasEffect;
	}
    }
    // FIXME: remove static for thread saftey
    static final EffectChecker effects = new EffectChecker();

    boolean isCopy(Expr _exp) {
	if (_exp.dest == null || !(_exp instanceof IRExpr))
	    return false;
	IRExpr exp = (IRExpr) _exp;
	if (!(exp.source instanceof ValueAccessExp))
	    return false;
	J2cValue v = ((ValueAccessExp) exp.source).v;
	if (v.isConcrete() || v.kind == J2cValue.NOVAR
	    || (v.getBlueprint(mc.ctx.domain)
		!= exp.dest.getBlueprint(mc.ctx.domain)))
	    return false;
	return (!mc.ctx.dontRenameLocals
		|| exp.dest.kind != J2cValue.LOCAL
		// Allow rename from local to stack slot (which we do
		// in reverse order), but don't allow renaming to
		// discard local variable names.
		|| v.kind == J2cValue.STACK_SLOT);
    }

    
    public class DUChain extends Dataflow.Backward {
	DU[][] block;
	BitSet[] out;

	DUChain(MethodCompiler mc) {
	    super(mc);
	    block = new DU[mc.block.length][];
	    out = new BitSet[mc.block.length];
	    ArrayList tmp = new ArrayList();

	    // In the first pass, allocate a DU node for every copy
	    // definition, and if needed, one that captures defs and
	    // uses before the first copy.
	    //
	    // gen is the set of uses that we generate, and kill is
	    // the set of variables we define.  As a side effect, this
	    // pass fills uses, varUses, copies, and varCopies.
	    for (int i = mc.block.length; i --> 0; ) {
		BitSet gen = new BitSet();
		BitSet kill = new BitSet();
		BBSpec b = mc.block[i];
		Expr code[] = b.code;
		for (int j = code.length; j --> 0; ) {
		    if (code[j] == null)
			continue;
		    if (code[j].dest != null) {
			// Save uses after this point (including uses
			// of our LHS)
			if (isCopy(code[j])) {
			    tmp.add(makeCopy(gen, kill, b, j));
			    gen = new BitSet();
			    kill = new BitSet();
			} else if (code[j].dest.kind != J2cValue.STACK_SLOT) {
			    tmp.add(makeDef(gen, kill, b, j));
			    gen = new BitSet();
			    kill = new BitSet();
			}
			// kill uses generated by subsequent exprs
			// that we elide into a single DU object
			BitSet k = varUses[code[j].dest.number];
			kill.or(k);
			gen.andNot(k);
		    }
		    // Remember uses we generate on our RHS
		    addExprUses(gen, b, j);
		}
		if (gen.cardinality() != 0 || kill.cardinality() != 0)
		    tmp.add(new DU(gen, kill));

		block[i] = new DU[tmp.size()];
		for (int j = 0; j < block[i].length; j++)
		    block[i][j] = (DU) tmp.get(block[i].length - j - 1);
		tmp.clear();
		out[i] = new BitSet();
	    }

	    // Exception handlers kill their parameter
	    if (mc.tryBlock != null)
		mc.tryBlock.accept(new TryBlock.Visitor() {
			public void visit(TryBlock _) { }
			public void visit(TryBlock _, TryBlock.Handler h) {
			    int i = h.block.number;
			    if (block[i].length == 0)
				block[i] = new DU[] {
				    new DU(new BitSet(), new BitSet())
				};
			    BitSet k = varUses[h.catchVar.number];
			    block[i][0].kill.or(k);
			    block[i][0].gen.andNot(k);
			}
		    });
	}

	public boolean run(BBSpec b) {
	    DU[] du = block[b.number];

	    BitSet in = new BitSet();
	    for (int i = b.next.length; i --> 0; )
		in.or(out[b.next[i].number]);

	    BitSet ex = new BitSet();
	    for (int i = b.handler.length; i --> 0; )
		ex.or(out[b.handler[i].number]);
	    in.or(ex);

	    for (int i = du.length; i --> 0; ) {
		in.andNot(du[i].kill);
		in.or(du[i].gen);
		in.or(ex);
		in.copyInto(du[i].in);
	    }
	    if (!out[b.number].equals(in)) {
		if (this.mc.debug)
		    System.err.println("block " + b.number + "@" + b.startPC +
				       " uses " + usesToString(in));
		out[b.number] = in;
		return true;
	    } else {
		if (this.mc.debug)
		    System.err.println("block " + b.number + "@" + b.startPC +
				       " unchanged");
		return false;
	    }
	}

	public int removeDeadStores() {
	    int nRemoved = 0;
	    BitSet tmp = new BitSet();
	    boolean changed;
	    do {
		changed = false;
		for (int i = block.length; i --> 0; )
		// The first DU in a block is not a Def. (It contains
		// the kill of the Def's left-hand-side.)  Subsequent
		// DUs are all defs.
		    for (int j = block[i].length; j --> 0; )
			if (block[i][j] instanceof Def) {
			    Def d = (Def) block[i][j];
			    d.in.copyInto(tmp);
			    tmp.and(varUses[d.getLHS().number]);
			    if (tmp.nextSetBit(0) == -1) {
				if (verbose)
				    System.err.println(d.b.startPC + "+" + d.idx +
						       ": remove dead store to " +
						       d.getLHS().name);
				nRemoved++;
				block[i][j] = null;
				changed = true;
				if (effects.in(d.b.code[d.idx]))
				    d.b.code[d.idx].dest = null;
				else
				    dropExpr(d.b, d.idx);
			    }
			}
	    } while (changed);
	    return nRemoved;
	}
    }

    public class AvailableCopies extends Dataflow.Forward {
	BitSet[] gen;
	BitSet[] kill;
	BitSet[] in;
	BitSet[] out;
	BitSet[] hOut;

	public void toString(StringBuffer b, BitSet c) {
	    String pfx = "";
	    for (int i = c.nextSetBit(0);
		 i != -1;
		 i = c.nextSetBit(i + 1)) {
		b.append(pfx);
		if (i >= copyArray.length) {
		    b.append("UNKNOWN COPY ");
		    b.append(i);
		} else if (copyArray[i].present()) {
		    b.append(copyArray[i].getLHS().name);
		    b.append("=");
		    b.append(copyArray[i].getRHS().name);
		}
		pfx = ", ";
	    }
	}

	public void toString(StringBuffer b, int i) {
	    b.append("block ");
	    b.append(i);
	    b.append("@");
	    b.append(this.mc.block[i].startPC);
	    b.append("\n  in   = ");
	    toString(b, in[i]);
	    b.append("\n  gen  = ");
	    toString(b, gen[i]);
	    b.append("\n  kill = ");
	    toString(b, kill[i]);
	    b.append("\n  out  = ");
	    toString(b, out[i]);
	    if (hOut[i] != null) {
		b.append("\n  hOut = ");
		toString(b, hOut[i]);
	    }
	    b.append("\n");
	}

	public String toString(int i) {
	    StringBuffer b = new StringBuffer();
	    toString(b, i);
	    return b.toString();
	}

	public String toString() {
	    StringBuffer b = new StringBuffer();
	    for (int i = 0; i < in.length; i++)
		toString(b, i);
	    return b.toString();
	}

	AvailableCopies(MethodCompiler mc) {
	    super(mc);

	    in = new BitSet[mc.block.length];
	    gen = new BitSet[mc.block.length];
	    kill = new BitSet[mc.block.length];
	    out = new BitSet[mc.block.length];
	    hOut = new BitSet[mc.block.length];

	    for (int i = 0; i < mc.block.length; i++) {
		in[i] = new BitSet();
		if (i != 0)
		    in[i].set(0, copies.size());
		gen[i] = new BitSet();
		kill[i] = new BitSet();
		Expr[] code = mc.block[i].code;
		for (int j = 0; j < code.length; j++) {
		    if (code[j] != null && code[j].dest != null) {
			BitSet kill = varCopies[code[j].dest.number];
			gen[i].andNot(kill);
			this.kill[i].or(kill);
			Copy c = (Copy) copies.get(code[j]);
			if (c != null)
			    gen[i].set(c.number);
		    }
		}
		out[i] = new BitSet();
		// make sure that out changes after the first pass
		// through each block!
		out[i].set(0, copies.size());
		if (mc.block[i].handler.length > 0) {
		    hOut[i] = new BitSet();
		    hOut[i].set(0, copies.size());
		}
	    }

	    // Exception handlers kill their parameter
	    if (mc.tryBlock != null)
		mc.tryBlock.accept(new TryBlock.Visitor() {
			public void visit(TryBlock _) { }
			public void visit(TryBlock _, TryBlock.Handler h) {
			    BitSet pKilled = varCopies[h.catchVar.number];
			    kill[h.block.number].or(pKilled);
			}
		    });
	}

	boolean run(BBSpec block) {
	    int i = block.number;
	    if (this.mc.debug)
		System.err.print(toString(i));
	    boolean hChange = false;
	    if (block.handler.length != 0) {
		BBSpec[] handler = block.handler;
		BitSet hOut = (BitSet) in[i].clone();
		hOut.andNot(kill[i]);
		if (!hOut.equals(this.hOut[i])) {
		    for (int j = handler.length; j --> 0; )
			in[handler[j].number].and(hOut);
		    this.hOut[i] = hOut;
		    hChange = true;
		}
	    }
	    BitSet out = (BitSet) in[i].clone();
	    out.andNot(kill[i]);
	    out.or(gen[i]);
	    if (!out.equals(this.out[i])) {
		BBSpec[] next = block.next;
		for (int j = next.length; j --> 0; )
		    in[next[j].number].and(out);
		this.out[i] = out;
		if (this.mc.debug) {
		    System.err.print(toString(i));
		    System.err.println("change -> next");
		}
		return true;
	    } else {
		if (this.mc.debug && hChange) {
		    System.err.print(toString(i));
		    System.err.println("change -> handlers");
		}
		return hChange;
	    }
	}
    }

    public CopyPropagation(MethodCompiler mc) {
	this.mc = mc;
	verbose = VERBOSE || mc.debug;
	stats = STATS || mc.debug;
	varUses = new BitSet[mc.allocator.nVars()];
	varCopies = new BitSet[varUses.length];
	for (int i = 0; i < varUses.length; i++) {
	    varUses[i] = new BitSet();
	    varCopies[i] = new BitSet();
	}
	UseAllocator ua = new UseAllocator();
	exprUses = new Use[mc.block.length][];
	for (int i = 0; i < exprUses.length; i++) {
	    BBSpec b = mc.block[i];
	    exprUses[i] = new Use[b.code.length];
	    for (int j = 0; j < b.code.length; j++)
		ua.allocate(b, j);
	}
    }

    private int nExprs() {
	int ret = 0;
	for (int i = 0; i < mc.block.length; i++)
	    ret += mc.block[i].code.length;
	return ret;
    }

    private void rename(J2cValue from, J2cValue to, Copy c) {
	BitSet vc =  varCopies[from.number];
	for (int i = vc.nextSetBit(0);
	     // The reasoning here is subtle:  Copies are allocated
	     // starting at the end of the program, then considered
	     // starting at the beginning.  We do not need to set
	     // rhsRename for a copy that we've already considered, so
	     // we only set it for copies with smaller numbers.
	     i != -1 && i < c.number;
	     i = vc.nextSetBit(i+1)) {
	    Copy c2 = copyArray[i];
	    if (!c2.present())
		continue;
	    while (c2.rhsRename != null) {
		if (c2 == c)
		    throw new Error("rhs cycle");
		c2 = c2.rhsRename;
	    }
	    c2.rhsRename = c;
	}
	varUses[to.number].or(varUses[from.number]);
	dropExpr(c.b, c.idx);
	mc.allocator.rename(from, to);
    }

    public String usesToString(BitSet s) {
	StringBuffer b = new StringBuffer();
	String pfx = "";
	for (int i = s.nextSetBit(0); i != -1; i = s.nextSetBit(i+1)) {
	    Use u = (Use) uses.get(i);
	    b.append(pfx);
	    b.append(u.var.name);
	    b.append("@");
	    b.append(u.b.startPC);
	    b.append("+");
	    b.append(u.idx);
	    pfx = ", ";
	}
	return b.toString();
    }

    int countLocalRefs() {
	J2cValue[] allVars = mc.allocator.getAllVars();
	int ret = 0;
	for (int i = 0; i < allVars.length; i++)
	    if (allVars[i] != null
		&& allVars[i].kind == J2cValue.LOCAL_VAR
		&& allVars[i].flavor == LocalAllocator.REF_VAR)
		ret++;
	return ret;
    }

    public void run() {
	if (stats) {
	    System.err.println("\nCopy Propagation in " +
			       mc.meth.getSelector());
	    System.err.println("vars:       " + mc.allocator.nVars());
	    System.err.println("local refs: " + countLocalRefs());
	    System.err.println("blocks:     " + mc.block.length);
	    System.err.println("exprs:      " + nExprs());
	}
	DUChain du = new DUChain(mc);
	if (stats) {
	    System.err.println("uses:       " + uses.size());
	    System.err.println("copies:     " + copies.size());
	    System.err.println("other defs: " + otherDefs);
	}
	du.run();
	int useless = du.removeDeadStores();
	if (stats && useless > 0)
	    System.err.println("removed:    " + useless + " dead stores");

	copyArray = new Copy[copies.size()];
	for (Iterator it = copies.values().iterator(); it.hasNext(); ) {
	    Copy copy = (Copy) it.next();
	    copyArray[copy.number] = copy;
	}

	AvailableCopies ac = new AvailableCopies(mc);
	ac.run();

	BitSet tmp = new BitSet();
	int partial = 0;
	int simple = 0;
	int cascaded = 0;
	int swapped = 0;
	int unified = 0;
	ArrayList swappableRenames = new ArrayList();
	outer: for (int cidx = copyArray.length; cidx --> 0; ) {
	    Copy c = copyArray[cidx];
	    // Ignore copies that are also dead stores
	    if (c.b.code[c.idx] == null)
		continue;

	    J2cValue from = c.getLHS();
	    int fidx = from.number;
	    J2cValue to = c.getRHS();
	    int tidx = to.number;
	    if (varUses[fidx].nextSetBit(0) == -1) {
		System.err.println(c.b.startPC + "+" + c.b.number +
				   ": dead copy " + from.name + " = " +
				   to.name + " found late");
		// Treat unused variables specially, otherwise we will
		// get into trouble.
		c.b.code[c.idx] = null;
		useless++;
		continue;
	    }
	    c.in.copyInto(tmp);
	    tmp.and(varUses[fidx]);
	    for (int i = tmp.nextSetBit(0);
		 i != -1;
		 i = tmp.nextSetBit(i + 1)) {
		Use u = (Use) uses.get(i);
		Expr[] code = u.b.code;
		if (u.b == c.b && u.idx > c.idx) {
		    for (int j = c.idx + 1; j < u.idx; j++) {
			if (code[j] != null && code[j].dest != null
			    && (code[j].dest.number == fidx
				|| code[j].dest.number == tidx)) {
			    if (verbose)
				System.err.println(c.b.startPC + "+" + c.idx +
						   ": CANNOT rename " +
						   from.name + " to " +
						   to.name);
			    continue outer;
			}
		    }
		} else {
		    for (Copy c2 = c; c2 != null; c2 = c2.rhsRename)
			if (!ac.in[u.b.number].get(c2.number)) {
			    if (verbose)
				System.err.println(c.b.startPC + "+" + c.idx +
						   ": CANNOT rename " +
						   from.name + " to " +
						   to.name);
			    continue outer;
			}
		    for (int j = 0; j < u.idx; j++) {
			if (code[j] != null && code[j].dest != null
			    && (code[j].dest.number == fidx
				|| code[j].dest.number == tidx)) {
			    if (verbose)
				System.err.println(c.b.startPC + "+" + c.idx +
						   ": CANNOT rename " +
						   from.name + " to " +
						   to.name);
			    continue outer;
			}
		    }
		}
	    }
	    if (!tmp.equals(varUses[fidx])) {
		partial++;
		if (verbose) {
		    System.err.print(c.b.startPC + "+" + c.idx +
				     ": PARTIAL rename " +
				     from.name + " to " + to.name);
		    System.err.print(" reaches ");
		    System.err.print(usesToString(tmp));
		    System.err.print(" but not ");
		    tmp.xor(varUses[fidx]);
		    System.err.println(usesToString(tmp));
		}
	    } else if (to.kind == J2cValue.STACK_SLOT
		&& from.kind == J2cValue.LOCAL_VAR) {
		// Remember, we are renaming from -> to.  That means that
		// ALL references to `from' may be replaced by references to
		// `to'.  This implies that ALL references to `to' can be
		// replaced by references to `from'.
		rename(to, from, c);
		swapped++;
// 		swappableRenames.add(c);
	    } else {
		if (mc.debug)
		    System.err.println(c.b.startPC + "+" + c.idx + ": rename " +
				       from.name + " to " + to.name);
		rename(from, to, c);
		simple++;
	    }
	}

	if (stats)
	    System.err.println("renamed:    " + simple + " normally");
	if (stats && swapped != 0)
	    System.err.println("renamed:    " + swapped + " swapped");
	if (useless != 0) {
	    if (mc.tryBlock != null) {
		final int catchUse = uses.size();
		mc.tryBlock.accept(new TryBlock.Visitor() {
			public void visit(TryBlock _) { }
			public void visit(TryBlock _, TryBlock.Handler h) {
			    varUses[h.catchVar.number].set(catchUse);
			}
		    });
	    }
	    J2cValue[] allVars = mc.allocator.getAllVars();
	    for (int i = 0; i < allVars.length; i++)
		if (allVars[i] != null
		    && allVars[i].kind != J2cValue.STACK_SLOT
		    && varUses[allVars[i].number].nextSetBit(0) == -1
		    && !(mc.meth.getMode().isSynchronized()
			 && allVars[i].kind == J2cValue.LOCAL_VAR
			 && allVars[i].index == 0)) {
		    if (mc.debug)
			System.err.println("remove var " + allVars[i].name);
		    mc.allocator.remove(allVars[i]);
		}
	}
	if (stats && simple + swapped + useless != 0)
	    System.err.println("local refs: " + countLocalRefs());
    }
}
	
