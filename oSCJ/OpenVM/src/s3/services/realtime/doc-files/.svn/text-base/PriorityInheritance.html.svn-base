<html xmlns:o="urn:schemas-microsoft-com:office:office" xmlns:w="urn:schemas-microsoft-com:office:word" xmlns="http://www.w3.org/TR/REC-html40">

<head>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<meta name="ProgId" content="FrontPage.Editor.Document">
<meta name="Generator" content="Microsoft FrontPage 4.0">
<meta name="Originator" content="Microsoft Word 9">
<link rel="File-List" href="file://Hypert/dholmes/pces/OpenVM-clean/src/s3/services/realtime/doc-files/PriorityInheritanceForRTSJinOVM_files/filelist.xml">
<title>Priority Inheritance Protocols and their Implementation</title>
</head>

<body>

<div class="Section1">
  <h1>An Implementation of the Priority Inheritance Protocol for Real-time Java</h1>
  <h5>David Holmes</h5>
  <p>In &quot;Priority Inheritance Protocols and their Implementation&quot; we
  discussed the behaviour of different priority inheritance protocols and their
  basic implementations under a strict set of execution restrictions. We also
  discussed how these restrictions (no blocking, no programmatic changing of
  priority etc) were not met in a <a href="http://www.rtsj.org">real-time Java</a>
  environment, and that consequently implementation of some of those protocols
  -- notably the Basic Priority Inheritance Protocol (BPIP) -- was greatly
  complicated compared to the simple schemes outlined in the literature. In this
  document we discuss an implementation approach for the BPIP within a real-time
  Java environment.</p>
  <h2>Basic Concepts and Definitions</h2>
  <p>The <b>base priority</b> of a thread is the priority assigned to the thread
  by the application program. In terms of the Realtime Specification for Java,
  this is the priority defined in the <tt>PriorityParameters</tt> object bound
  to the realtime thread and which we assume can be changed at any time.</p>
  <p>The <b>active priority</b> of a thread is its current execution priority as
  seen by the scheduler. This is the priority value used to establish execution
  eligibility and to order the thread on any system queues that are ordered by
  priority (such as monitor lock acquisition queues, and monitor wait-set
  queues).</p>
  <p>The <b>owner</b> of a monitor is the thread that currently holds the
  monitor lock.</p>
  <p>The <b>lock-set</b> of a monitor is the set of all threads blocked trying
  to acquire that monitor (ordered by active priority).</p>
  <p>The <b>top</b> of the lock-set is the thread with the highest active
  priority.</p>
  <p>The lock-set.top thread <b>bequests</b> its priority to the monitor owner.
  If the bequested priority is greater than the owners active priority then the
  owner <b>inherits</b> the bequested priority as its active priority. The
  lock-set.top thread is known as a <b>priority source</b> for the monitor
  owner.</p>
  <p>The <b>owned-set</b> is the set of monitors owned by a thread.</p>
  <p>The <b>inheritance-queue</b> of a thread is the ordered set of priority
  sources for that thread. The <b>top</b> of the inheritance-queue is the thread
  with the highest active priority.</p>
  <h2>Properties and Invariants</h2>
  <p><b>Invariant:</b> for all threads <tt>t</tt>
  <ul>
    <li><tt>t.activePriority &gt;= t.basePriority</tt></li>
  </ul>
  <p><b>Invariant:</b> for all threads <tt>t</tt>
  <ul>
    <li><tt>t.activePriority = max(t.basePriority,
      t.inheritanceQueue.top.activePriority)</tt></li>
  </ul>
  <p><b>Invariant:</b> for all threads <tt>t</tt>, for all monitors <tt>m</tt>
  in <tt>t.ownedSet</tt>:
  <ul>
    <li><tt>t.inheritanceQueue.contains(m.lockSet.top)</tt></li>
  </ul>
  <p><b>Invariant:</b> a thread can exist in only one lock-set at a time, and so
  only in one inheritance queue.
  <p><b>Invariant:</b> for all monitors <tt>m</tt>:
  <ul>
    <li><tt>m.owner.activePriority &gt;= m.lockSet.top.activePriority</tt></li>
  </ul>
  <p><b>Invariant:</b> for all threads <tt>t</tt>:
  <ul>
    <li><tt>t.ownedSet.size() &gt;= t.inheritanceQueue.size()</tt></li>
  </ul>
  <p><b>Property:</b> when a thread <tt>t</tt> is started:
  <ul>
    <li><tt>t.ownedSet.size() == 0</tt></li>
    <li><tt>t.inhertanceQueue.size() == 0</tt></li>
    <li><tt>t.activePriority == t.basePriority</tt></li>
  </ul>
  <p><b>Property:</b> when a thread <tt>t</tt> terminates:
  <ul>
    <li><tt>t.ownedSet.size() == 0</tt></li>
    <li><tt>t.inhertanceQueue.size() == 0</tt></li>
    <li><tt>t.activePriority == t.basePriority</tt></li>
  </ul>
  <h3>Basic Operation</h3>
  There are four actions that affect the operation of the priority inheritance
  protocol:
  <ol>
    <li>A thread blocks trying to acquire a monitor lock (either directly
      through entry to a <tt>synchronized</tt> method or statement, or
      indirectly when returning from a call to <tt>Object.wait()</tt>) and so
      may become a priority source for the owning thread
    <li>A thread moves to the top of the lock-set for a monitor (because the
      previous top thread has either acquired the monitor or abandoned its
      attempt) and so becomes a priority source for the current owner
    <li>A thread releases a monitor lock (and so loses the priority source from
      that monitor)
    <li>A thread has its priority changed. Depending on the state of the thread
      this might cause it to become a priority source, or cease to be a priority
      source; or simply require a change to the active priority of the thread
      for which it is a priority source.
  </ol>
  <p>Iin all cases correct operation simply involves maintaining the invariants
  that were previously listed, for all threads. We define two helper functions
  to express the basic actions that must occur in each case: <tt>maintainPriority</tt>
  and <tt>propagatePriority</tt>.
  <p><b><tt>MaintainPriority:</tt></b> Causes a thread to check that it’s
  active priority invariant is met, and if not to change its active priority so
  that the invariant is met. An implementation can optimise things by checking
  for actual changes in active priority.
  <p><b><tt>PropagatePriority:</tt></b> For a thread <tt>t</tt> this has the
  following effect:
  <pre>      if t is blocked acquiring a monitor m then 
           m.lockSet.reposition(t); // ensure the lock set is correctly ordered 
           if m.lockSet.top != old m.lockSet.top then
               m.owner.inheritanceQueue.remove(old m.lockSet.top);
               m.owner.inheritanceQueue.insert(m.lockSet.top); 
               m.owner.maintainPriority();
               m.owner.propagatePriority(); 
           else if t == m.lockSet.top then
               m.owner.inheritanceQueue.reposition(t); 
               m.owner.maintainPriority();
               m.owner.propogatePriority(); 
           else 
               nop 
       else if t is runnable/running
           reorder ready queue
       else
           nop 
  </pre>
  <h3>Monitor Acquisition</h3>
  If a thread <tt>t</tt> tries to acquire a monitor <tt>m</tt> and that monitor
  already has an owner other than <tt>t</tt>, then <tt>t</tt> is placed in the
  lock-set of <tt>m</tt> and the following occurs:
  <pre>     if (t == m.lockSet.top) then
         m.owner.inheritanceQueue.remove(old m.lockSet.top); 
         m.owner.inheritanceQueue.insert(t);
         m.owner.maintainPriority(); 
         m.owner.propagatePriority(); 
     else 
         nop</pre>
  When <tt>t</tt> eventually acquires the monitor then the following happens:
  <pre>      t.inheritanceQueue.insert(m.lockSet.top);
      t.maintainPriority(); 
      t.propagatePriority(); 
  </pre>
  <h3>Monitor Release</h3>
  <p>When a thread <tt>t</tt> releases a monitor <tt>m</tt>, such that <tt>t</tt>
  is no longer the owner of <tt>m</tt>, then the following occurs:
  <pre>      t.inheritanceQueue.remove(m.lockSet.top);
      t.maintainPriority(); 
      t.propagatePriority();
</pre>
  <h3>Priority Change</h3>
  <p>If a thread <tt>t</tt> has its priority changed to a value <tt>p</tt> then
  the following occurs:
  <pre>     t.basePriority = p;
     t.maintainPriority(); 
     t.propagatePriority(); 
</pre>
  <h2>Implementation in OVM</h2>
  The OVM implementation follows the basic operation previously described. It is
  provided by three classes in the <tt>s3.services.realtime package</tt> (for
  raw ED functionality):
  <ul>
    <li>PriorityInheritanceDispatcherImpl,
    <li>PriorityInheritanceOVMThreadImpl, and
    <li>PriorityInheritanceMonitorImpl
  </ul>
  and three corresponding classes in the <tt>s3.services.java.realtime</tt>
  package:
  <ul>
    <li>RealtimeJavaDispatcherImpl,
    <li>RealtimeJavaThreadImpl, and
    <li>PriorityInheritanceJavaMonitorImpl
  </ul>
  In each case, the thread class maintains the inheritance queue and determines
  its active priority, the dispatcher deals with priority changes (to the base
  priority) and provides the means to propagate any priority changes, and the
  monitor ensures monitor acquisition and release do the right thing (in each
  case by overriding hook methods from their superclass monitor implementation).
  The main operation in the dispatcher is called <tt>maintainPriorityRelations</tt>
  and combines the action of <tt>maintainPriority</tt> (by asking the thread)
  and <tt>propagatePriority</tt>.
</div>

</body>

</html>
