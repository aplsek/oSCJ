// HashtableName : HTObject
// KeyType : Object
// Compare : .equals
// HashFunction : .hashCode()
// NotFound : null
// Default size : 1024
// Synchronized : no
// Serializable : no
// Profiling : no
package ovm.util;

/**
 * This Hashtable is generated by TGen. Its key type is Object.
 * @author Ben L. Titzer
 * @author Christian Grothoff
 * @author TGen2
 */
public class HTObject extends ovm.core.OVMBase {

    // debug aid
    void log(String msg) {
        ovm.core.services.io.BasicIO.out.println(msg);
    }

    private int mask_;
    private int numElems_; // tracks the size of the hashtable
    private int maskCollisions_;
    private final static int DEFAULT_SIZE = 1024;
     final Object[] keys_;

    /**
     * If there is a collision, we keep the 'collided' elements in here (linked
     * list).
     */
     final Binding[] collisions_;
    private static final Object NOTFOUND = null;

    /**
     * Internal binding class. Stores a key, value, and a link to the next
     * binding in the chain.
     */
    static private final class Binding extends ovm.core.OVMBase {
        Binding link;
        Object key;
        Binding(Binding link, Object key) {
            this.link = link;
            this.key = key;
        }
    }

    protected HTObject(HTObject other) {
        complementaryView_ = other.complementaryView_;
        this.mask_ = other.mask_;
        this.maskCollisions_ = other.maskCollisions_;
        this.collisions_ = other.collisions_;
        this.keys_ = other.keys_;
    }

    protected HTObject complementaryView_;

    public HTObject getReadOnlyView() {
        if (complementaryView_ == null) {
            complementaryView_ = new ReadOnly(this);
        }
        return complementaryView_;
    }

    private static class ReadOnly extends HTObject {
        ReadOnly(HTObject other) {
            super(other);
            complementaryView_ = other;
        }

        public HTObject getReadOnlyView() {
            return this;
        }
        public void put(Object key) {
            if (contains(key))
                return;
            throw new ovm.util.ReadonlyViewException(key.toString());
        }
        public int size() {
            return complementaryView_.size();
        }
        public void remove(Object key) {
            throw new ovm.util.ReadonlyViewException();
        }

    }

    /**
     * Public default constructor.
     */
    public HTObject() {
        this(DEFAULT_SIZE);
    }

    /**
     * Constructor that specifies a hint size.
     */
    public HTObject(int hint) {
        int size = 8;
        int sizeCollisions;
        while (size < hint)
            size *= 2;
        mask_ = size - 1;
        sizeCollisions = size >> 3;
        maskCollisions_ = sizeCollisions - 1;
        /* make collision table 1/8th of the size of the main table */
        this.collisions_ = new Binding[sizeCollisions];
        this.keys_ = new Object[size];

    }

    /**
     * Return the size (number of elements currently present) of the hashtable.
     */
    public int size() {
        return numElems_;
    }

    public boolean contains(Object key) {
        return get(key) != NOTFOUND;
    }

    public void add(Object key) {
        put(key);
    }

    /**
     * Get a key matching the given key based on some equals function.
     */
    public final Object get(Object key) {
        int hash = mask_ & key.hashCode();
        Object keys_hash = keys_[hash];
        if (keys_hash == null) {

            return NOTFOUND;
        }
        if (key.equals(keys_hash)) {

            return keys_hash;
        }
        return findInCollisions(maskCollisions_ & hash, key);
    }

    /**
     * Put a key into the hashtable. Checks to see if the key is already in the
     * hashtable, and if not, inserts it into the hashtable.
     */
    public void put(Object key) {
//         log("Storing: " + key);
        int hash = mask_ & key.hashCode();
        Object keys_hash = keys_[hash];
        if (keys_hash == null) { // simple insert
            keys_[hash] = key;
            numElems_++;
//             log("\t - simple insertion");
            return;
        }
        if (key.equals(keys_hash)) { // replace
//             log ("\t - replacement");
            return;
        }
        // collision
        int hashCollision = hash & maskCollisions_;
        insertInCollisions(hashCollision, key);

    }

    /**
     * Private function to search the collision table for a key. Searches the
     * collisions_ table starting at the given offset until either the correct
     * Binding is found or the end of the list is reached.
     */
    private final Object findInCollisions(int offset, Object key) {
        Binding p;

        for (p = collisions_[offset]; p != null; p = p.link) {
            if (key.equals(p.key)) {
                return p.key;
            }

        }
        return NOTFOUND;
    }

    /**
     * Private function to insert a key into the collision table. Searches the
     * collisions_ table starting at the given offset and continues until
     * either the correct Binding is found, or the end of the list is reached.
     * If no Binding is found with the correct key, it will create a new
     * Binding to hold the key.
     */
    private final void insertInCollisions(int offset, Object key) {
        Binding h = collisions_[offset], p;

        for (p = h; p != null; p = p.link) {
            if (key.equals(p.key)) {
//                 log("\t - replaced in collision");
                return;
            }

        }

        numElems_++;
        collisions_[offset] = new Binding(h, key);
//         log("\t - new entry in collision");
    }

    public void remove(Object key) {
//         log("Trying to remove: " + key);
        int hash = mask_ & key.hashCode();
        Object result = keys_[hash];
        if (result == NOTFOUND) {
//             log("\t - NOT FOUND");
            return;
        }
        if (key.equals(result)) {
//             log("\t - Found it");
            int offset = maskCollisions_ & hash;
            Binding p = collisions_[offset];
            numElems_--;
            for (; p != null; p = p.link)
                if ((mask_ & p.key.hashCode()) == hash)
                    break;
            if (p == null)
                keys_[hash] = NOTFOUND;
            else {
                Binding prev = collisions_[offset];
                if (prev == p)
                    collisions_[offset] = p.link;
                else {
                    while (prev.link != p)
                        prev = prev.link;
                    prev.link = p.link;
                }
                keys_[hash] = p.key;
            }
        } else {
            int offset = maskCollisions_ & hash;
            Binding p = collisions_[offset];
            for (; p != null; p = p.link)
                if (key.equals(p.key)) {
//                     log("\t - Found it in collision table");
                    break;
                }
            if (p != null) {
                numElems_--;
                Binding prev = collisions_[offset];
                if (prev == p) {
                    collisions_[offset] = p.link;
                } else {
                    while (prev.link != p)
                        prev = prev.link;
                    prev.link = p.link;
                }
            }
            else {
//                 log("\t - NOT FOUND in collision table");
            }
        }
    }

    public Iterator getIterator() {
        return new Iterator();
    }

    public final class Iterator {
        private int position_;
        private boolean iteratingOverKeys_;
        private Binding currentBinding_;
        private boolean reachEnd;

        Iterator() {
            currentBinding_ = collisions_[0];
            position_ = -1;
            iteratingOverKeys_ = true;
            reachEnd = false;
            findNext();
        }
        public boolean hasNext() {
            return !reachEnd;
        }
        public Object next() {
            Object res;
            if (iteratingOverKeys_) {
                res = keys_[position_];
            } else {
                res = currentBinding_.key;
            }
            findNext();
            return res;
        }
        public void remove() {
            throw new Error("Remove Not Implemented");
        }

        private void findNext() {
            if (iteratingOverKeys_) {
                position_++;
                while (position_ < keys_.length && keys_[position_] == null)
                    position_++;
                if (position_ == keys_.length) {
                    iteratingOverKeys_ = false;
                    position_ = 0;
                    while (position_ < collisions_.length
                        && collisions_[position_] == null)
                        position_++;
                    if (position_ == collisions_.length)
                        reachEnd = true;
                    else
                        currentBinding_ = collisions_[position_];
                }
            } else {
                currentBinding_ = currentBinding_.link;
                if (currentBinding_ == null) {
                    position_++;
                    while (position_ < collisions_.length
                        && collisions_[position_] == null)
                        position_++;
                    if (position_ == collisions_.length)
                        reachEnd = true;
                    else
                        currentBinding_ = collisions_[position_];
                }
            }
        }
    } // End Iterator

} // End HTObject
