package ovm.core.execution;
import ovm.core.domain.Method;
import ovm.core.domain.Oop;
import ovm.core.services.memory.VM_Address;
import ovm.core.stitcher.InvisibleStitcher;
import ovm.core.stitcher.InvisibleStitcher.PragmaStitchSingleton;
import s3.core.domain.S3ByteCode;
import ovm.core.Executive;
import ovm.core.domain.Code;

/**
 * The interface for generating trampoline and thunk code.  We provide
 * a fast implementation for x86 and powerpc, and a portable
 * implementation for other platforms.
 **/
public abstract class Trampoline {
    /**
     * Call compileMethod with two arguments: this (compileObject), and
     * a Code object (the first argument of the trampoline.
     * compileMethod will return a new code entry point, which this
     * method should then make a tail-call through.
     **/
    public abstract VM_Address compileAndRestart(S3ByteCode origCode,
						 Code compileMethod,
						 Object compileObject);

    /**
     * Prepend an argument to the argument list, and call through
     * another function pointer.  The remainder of the function's
     * arguments are given by otherArguments, in the format used by 
     * {@link ovm.core.domain.Code.signature}.  If saveAllRegisters is
     * true, this thunk should spill all callee-save registers to the
     * stack.
    public abstract VM_Address prependAndCall(Oop prependedArgument,
					      byte[] otherArguments,
					      VM_Address entryPoint);
     **/

    /**
     * A mutable thunk that will perform a tail call to a
     * function, fn, with a single pointer argument, arg.
     * <p>
     * Perhaps there should be an option to support multiple
     * arguements.  We'll have to see what simplejit exception
     * dispatch looks like under the new regime.
     * @see Trampoline#makeTailcallWithArguments
     **/
    static public interface TailcallWithArguments {
	/**
	 * Return the address of this thunk's executable code.
	 **/
	VM_Address getAddress();
	/**
	 * Set the function called by this thunk.  fn should be a
	 * pointer to a function that takes the number of arguments
	 * specified in {@link Trampoline#makeTailcallWithArguments},
	 * and no more arguments than the call this thunk will
	 * replace.
	 **/
	void setTarget(VM_Address fn);
	/** Set the argument passed to fn **/
	void setArgument(VM_Address arg);
    }

    /**
     * Return a mutable thunk.  This really can't be implemented in
     * the postulated LibFFITrampoline, but that is OK, because it will only
     * be used when {@link #isCxxExceptionSafe} is false.
     * <p>
     * If the thunk is used to replace standard java method calls on
     * the stack, nargs should be no more than two.  (Standard method
     * calls take at least two arguments, the
     * {@link ovm.core.domain.Code Code} object, and the method's
     * receiver.  Passing additional arguments on x86 may corrupt the
     * caller's stack frame.)
     **/
    public TailcallWithArguments makeTailcallWithArguments(int nargs) {
	throw Executive.panic("unimplmented!");
    }

    /**
     * Return true if code generated by this trampoline implementation
     * is compatible with C++ exception handlers.
     **/
    public boolean isCxxExceptionSafe() {
	return false;
    }

    static public Trampoline the() throws PragmaStitchSingleton {
	return (Trampoline) InvisibleStitcher.singletonFor(Trampoline.class);
    }
}
