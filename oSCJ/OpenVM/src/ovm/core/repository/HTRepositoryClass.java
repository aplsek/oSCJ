/** 
 * This hashtable class is generated by TGen 2.0r.
 *
 * PLEASE DO NOT MODIFY THIS SOURCE.
 *
 * @author Ben L. Titzer
 * @author TGen2
 **/

// HashtableName : HTRepositoryClass
// KeyType       : RepositoryClass
// Compare       : .equals
// HashFunction  : .hashCode()
// NotFound      : null
// Default size  : 1024
// Synchronized  : no
// Serializable  : no
// Profiling     : no 

package ovm.core.repository;

 


/**
 * This Hashtable is generated by TGen. Its key type is RepositoryClass.
 * @author Ben L. Titzer
 * @author Christian Grothoff
 * @author TGen2
 **/
public class HTRepositoryClass extends ovm.core.OVMBase 
  {

    private int mask_;
    private int numElems_;                 // tracks the size of the hashtable
    private int maskCollisions_;
    private final static int DEFAULT_SIZE = 1024;
    final RepositoryClass[] keys_;

    /**
     * If there is a collision, we keep the 'collided' elements in here (linked list).
     **/
    final Binding[] collisions_;
    private static final RepositoryClass NOTFOUND = null; 



    /**
     * Internal binding class. Stores a key, value, and a link
     * to the next binding in the chain.
     **/
    static private final class Binding extends ovm.core.OVMBase {
	Binding link;
	RepositoryClass key;
	Binding(Binding link, RepositoryClass key) {
	    this.link = link;
	    this.key = key;
	} 
    }

    protected HTRepositoryClass(HTRepositoryClass other) {
 	complementaryView_ = other.complementaryView_;
 	this.mask_ = other.mask_;
 	this.maskCollisions_ = other.maskCollisions_;
 	this.collisions_ = other.collisions_;
 	this.keys_ = other.keys_;
    }

    protected HTRepositoryClass complementaryView_;

    public  HTRepositoryClass getReadOnlyView() {
	if (complementaryView_ == null) {
		complementaryView_ = new ReadOnly(this);
	}		
	return complementaryView_;
    } 
	  
    private static class ReadOnly extends HTRepositoryClass {
	ReadOnly(HTRepositoryClass other) {	
		super(other);
	 	complementaryView_ = other;
	}

	public HTRepositoryClass getReadOnlyView() {
		return this;
	}
 	public void put(RepositoryClass key) {
		if (contains(key)) 
			return;
		throw new ovm.util.ReadonlyViewException(key.toString());
	}
 	public int size() {
        	return complementaryView_.size();
    	}
    	public void remove(RepositoryClass key) {
		throw new ovm.util.ReadonlyViewException();
	}
	
    }


    /**
     * Public default constructor.
     **/
    public HTRepositoryClass() {
	this(DEFAULT_SIZE);
    }

    /**
     * Constructor that specifies a hint size.
     **/
    public HTRepositoryClass(int hint) {	    
        int size = 8;
	int sizeCollisions;
        while ( size < hint ) size *= 2;
        mask_ = size-1;
	sizeCollisions = size>>3;
	maskCollisions_ = sizeCollisions-1; /* make collision table 1/8th of the size of the main table */
	this.collisions_ = new Binding[sizeCollisions];
	this.keys_ = new RepositoryClass[size];

    }


    /**
     * Return the size (number of elements currently present) of the hashtable.
     **/
    public int size() {
        return numElems_;
    }

    public boolean contains(RepositoryClass key) {
	return get(key) != NOTFOUND;
    }

    public void add(RepositoryClass key) {
        put(key);
    }

    /**
     * Get a key matching the given key based on some equals function.
     **/
    public final RepositoryClass get(RepositoryClass key) {
	int hash = mask_&key.hashCode();
	RepositoryClass keys_hash = keys_[hash];
	if (keys_hash == null) {
           
	   return NOTFOUND;
        }
	if (key.equals(keys_hash)) {
           
	   return keys_hash;
        }
	return findInCollisions(maskCollisions_&hash, key);
    }

    /**
     * Put a key into the hashtable. Checks to see if
     * the key is already in the hashtable, and if not, inserts
     * it into the hashtable.
     **/
    public void put(RepositoryClass key) {
	int hash = mask_&key.hashCode();
   	RepositoryClass keys_hash = keys_[hash];
	if (keys_hash == null) { // simple insert
           keys_[hash] = key;
           numElems_++;
           
	   return;
        }     
        if (key.equals(keys_hash)) { // replace
           
           return;
        } 
        // collision
	int hashCollision = hash & maskCollisions_;
	insertInCollisions(hashCollision, key);
	
    }


    /**
     * Private function to search the collision table for a key.
     * Searches the collisions_ table starting at the given offset until
     * either the correct Binding is found or the end of the list is reached.
     **/
    private final RepositoryClass findInCollisions(int offset, RepositoryClass key) {
	Binding p;
	

	for (p = collisions_[offset]; p!= null; p = p.link) {
	    if (key.equals(p.key)) { 
               return p.key;
            }
	    
        } 
	return NOTFOUND;
    }

    /**
     * Private function to insert a key into the collision table.
     * Searches the collisions_ table starting at the given offset and
     * continues until either the correct Binding is found, or the end of
     * the list is reached. If no Binding is found with the correct key, it
     * will create a new Binding to hold the key.
     **/
    private final  void insertInCollisions(int offset, 
					 RepositoryClass key) {
	Binding h = collisions_[offset], p;
	

	for (p = h; p != null; p = p.link) {
	    if (key.equals(p.key)) { 
                
	        return;
            }
	    
        }

	numElems_++;
        collisions_[offset] = new Binding(h, key); 
    }


    public void   remove(RepositoryClass key) {
	int hash = mask_ & key.hashCode();
	RepositoryClass result = keys_[hash];
	if (result == NOTFOUND) return;
	if (key.equals(result)) {
	    int offset = maskCollisions_ & hash;	    
	    Binding p = collisions_[offset];
            numElems_--;
            for (; p!= null; p = p.link) 
		if ((mask_ & p.key.hashCode()) == hash) break;
	    if (p == null) keys_[hash] = NOTFOUND;
	    else {
		Binding prev = collisions_[offset];
		if (prev == p) collisions_[offset] = p.link;
		else {
		    while (prev.link != p) prev = prev.link;
		    prev.link = p.link;
		}
		keys_[hash] = p.key;
	    }
	} else {
	    int offset = maskCollisions_ & hash;	    
	    Binding p = collisions_[offset];
            for (; p!= null; p = p.link) 
		if (key.equals(p.key)) break;
	    if (p != null) {
	        numElems_--;
		Binding prev = collisions_[offset];
		if (prev == p) {
		    collisions_[offset] = p.link;
		} else {
		    while (prev.link != p) prev = prev.link;
		    prev.link = p.link;
		}
	    }
	}
    }

    public Iterator getIterator() { return new Iterator(); }
    
    public final class Iterator   {
	private int position_;
	private boolean iteratingOverKeys_;
	private Binding currentBinding_;
	private boolean reachEnd;
	
	Iterator() {
	    currentBinding_ = collisions_[0];
	    position_ = -1;
	    iteratingOverKeys_ = true;
	    reachEnd = false;
	    findNext();
	}
	public boolean hasNext() {
	    return !reachEnd;
        }
	public RepositoryClass next() {
	    RepositoryClass res;
	    if (iteratingOverKeys_) {
		res = keys_[position_];
	    } else {
		res = currentBinding_.key;
	    }
	    findNext();
	    return res;
	}
	public void remove() { throw new Error("Remove Not Implemented"); }

	private void findNext() {
	    if (iteratingOverKeys_) {
		position_++;
		while (position_ < keys_.length && 
		       keys_[position_] == null)
		    position_++;
		if (position_ == keys_.length) {
		    iteratingOverKeys_ = false;
		    position_ = 0;
		    while (position_ < collisions_.length &&
			   collisions_[position_] == null)
			position_++;
		    if (position_ == collisions_.length)
			reachEnd = true;
		    else
			currentBinding_ = collisions_[position_];
		}
	    } else {
		currentBinding_ = currentBinding_.link;
		if (currentBinding_ == null) {
		    position_++;
		    while (position_ < collisions_.length && 
			   collisions_[position_] == null)
			position_++;
		    if (position_ == collisions_.length)
			reachEnd = true;
		    else
			currentBinding_ = collisions_[position_];
		} 
	    }
        }
    } // End Iterator

	
} // End HTRepositoryClass

