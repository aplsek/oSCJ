<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head> <!-- ovm.core.domain package comments --> </head><body>

    <p>The <code>ovm.core.domain</code> package contains the interfaces
    that deal with domain-specific information, along with actual VM object
    type information and layout. </p>

    <p> A domain is essentially an application space; applications running
    in different domains have (conceptually) no interaction via shared
    objects. Two different domains might well contain two classes with the
    same name but different implementations (for example, one domain may
    contain a class that uses one version of <code>java.lang.String</code>,
    whereas another application may expect a different implementation of
    this class). The domain with which the application is associated will
    determine where classes will be searched for at resolution time. </p>

    <p> Information about objects and their types is stored in two
    different data structures. A <code>Type</code> contains information
    about a class and its structure and domain. Some information within a
    <code>Type</code> may be resolved lazily. A <code>Type</code> has a
    reference to its <code>Context</code>, which contains a reference to
    the <code>Type's</code> domain. Thus, every <code>Type</code> belongs
    to exactly one <code>Context</code>, and every <code>Context</code>
    refers to exactly one <code>Domain</code>. The <code>Type</code> can
    then be seen as a domain-specific representation of class
    information. </p>

    <p> Each <code>Type</code> is corresponds to a
    <code>RepositoryClass</code>; the <code>RepositoryClass</code>
    encapsulates the repository's view of the information contained in a
    class file. The <code>Type</code> object represents a particular
    domain's view of the associated class. (This means that there could be
    several different <code>Type</code> objects associated with a given
    <code>RepositoryClass</code> object.) </p>

    <p> As mentioned in the before, some information within a type may be
    filled in lazily. For example, if a class has a field which is never
    assigned to, the class representing that field's type may never be
    loaded. Since the field's type may never be resolved, the
    <code>Type</code> doesn't bother to encode that information until the
    actual resolution occurs. <code>Type</code> objects, then, may evolve
    at runtime. </p>

    <p> A <code>Blueprint</code>, on the other hand, represents an object's
    layout and the information necessary to create an instance of that
    object. This may include virtual method tables and other information,
    but this depends upon the implementation of
    <code>Blueprint</code>. Once an object has been created with a given
    instance of <code>Blueprint</code>, that <code>Blueprint</code> is then
    considered immutable. </p>

    <p> There is not necessarily a one-to-one mapping between
    <code>Types</code> and <code>Blueprints</code>. Every
    <code>Blueprint</code> <i>does</i> have exactly one associated
    <code>Type</code>; however, it is possible that an implementation may
    choose allow a <code>Type</code> to have several different
    <code>Blueprints</code> for various reasons.  For example, if there
    were a reason to add some bookkeeping information to some instances
    with a given <code>Type</code>, but not all of them, a second
    <code>Blueprint</code> could be associated with the type that had
    additional space for this information. Multiple <code>Blueprints</code>
    corresponding to the same type must still be compatible, however. </p>

    <p> <code>Domains</code>, then, are containers for
    <code>Blueprints</code> and <code>Types</code>. Similarly, a
    <code>Type</code> may have multiple <code>Blueprints</code>. </p>

    <p> Every object in the language being implemented is visible to the
    implementing language as an <code>Oop</code>. Each <code>Oop</code>, as
    the representation of an object, has a <code>Blueprint</code>; this
    <code>Blueprint</code> has a reference to its <code>Type</code>. </p>

    <p> Other associated objects, such as class member objects, are also
    included in the <code>ovm.core.domain</code> package. See specific
    class descriptions for details. </p>

    <p>N.B.: For the time being, there is a one-to-one correspondence
    between <code>Type</code> objects and <code>Blueprint</code>
    objects. However, KP indicated that this will hopefully change, at
    least as far as the higher-level concept is concerned
    (i.e. implementations may choose to keep this one-to-one, but this is a
    special case of one-to-many).</p>

    <p> An example of the interaction between <code>RepositoryClass</code>
    objects, <code>Types</code>, and <code>Blueprints</code> is shown
    below. This figure is based upon the following code:
      <pre>
      class A {
          static int bar;
          public int foo;
      }
      </pre></p>

    <p><br><img src="doc-files/blueprints.gif"><br></p>

    <p> As the figure shows, each instance of <code>A</code> is associated
    with a <code>Blueprint</code>. The instance object itself contains the
    values associated with that instance (in this case, the value of
    <code>foo</code>). Here there are two instances of <code>A</code>
    shown: <code>a1</code> and <code>a2</code>. Both were created from the
    same <code>Blueprint</code>, but could have different values for
    <code>foo</code>. </p>
    
    <p> The <code>Blueprint</code> associated with <code>a1</code> and
    <code>a2</code> describes the instance object layout. In this case, for
    example, it contains information about the offset of <code>foo</code>
    within the object. It also contains a reference to the
    <code>Type</code> object associated with class <code>A</code> in this
    domain. It also contains a reference to a shared-state object for class
    <code>A</code> as well as a reference to the <code>Blueprint</code> for
    all objects of class <code>Blueprint</code>; these are discussed in
    more detail below.</p>
      
    <p> A shared-state object is associated with each <code>Type</code>
    object. It functions much like an instance object, except that it
    contains any shared-state information for the class and, as such, there
    is only one such object per <code>Type</code>. For example, in
    <code>Java</code>, this object contains the values of
    <code>static</code> variables. In our example, then, this object would
    contain the value of <code>bar</code> for <i>all</i> instances of class
    <code>A</code>, since it is a class variable, not an instance
    variable.</p>
    
    <p> Like instance objects, the shared-state object has a
    <code>Blueprint</code> which describes its layout, including the
    offsets of member variables. To ensure that there is not an infinitely
    recursive chain of shared-state objects, the shared-state pointed to by
    a shared-state <code>Blueprint</code> is <code>null</code>.  The
    <code>Type</code> object referenced by a shared-state
    <code>Blueprint</code> is the same <code>Type</code> referenced by
    instance objects of the class. As with instance object
    <code>Blueprints</code> (and indeed <b>all</b>
    <code>Blueprints</code>), there is a reference to the
    <code>Blueprint</code> for instances of class
    <code>Blueprint</code>. </p>

    <p> For reference, it should be noted that <code>Blueprint</code>
    extends <code>Oop</code>. As mentioned before, all <code>Oop</code>
    objects have a <code>Blueprint</code>.  Thus, instances of class
    <code>Blueprint</code> also have a <code>Blueprint</code> describing
    their layout. In the figure, all <code>Blueprint</code> objects contain
    a <code>Blueprint</code> reference. As shown, these all point to the
    <code>Blueprint</code> for instances of the <code>Blueprint</code>
    class. This <code>Blueprint</code> contains the same kind of
    information that the <code>Blueprint</code> for instances of class
    <code>A</code> contains; a reference to the <code>Type</code> object
    associated with class <code>Blueprint</code>, a reference to the
    shared-state object, etc.</p>

</body></html>
