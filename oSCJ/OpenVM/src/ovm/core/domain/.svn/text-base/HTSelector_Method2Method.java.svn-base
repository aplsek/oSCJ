/** 
 * This hashtable class is generated by TGen 2.0r.
 *
 * PLEASE DO NOT MODIFY THIS SOURCE.
 *
 * @author Ben L. Titzer
 * @author Christian Grothoff
 * @author TGen2
 **/

// HashtableName : HTSel2Method
// KeyType : Selector.Method
// ValueType : Method
// Compare : .equals
// HashFunction : .hashCode()
// NotFound : null
// Default size : 16
// Synchronized : no
// Serializable : no
// Profiling : no

package ovm.core.domain;

import ovm.core.repository.Selector;

/**
 * This Hashtable is generated by TGen. Its key type is Selector.Method and its
 * value type is Method.
 * @author Ben L. Titzer
 * @author Christian Grothoff
 * @author TGen2
 */
final public class HTSelector_Method2Method extends ovm.core.OVMBase {

    public static final int MININT = -0x7fffffff;
    public static final Method NOTFOUND = null;

    private static final int DEFAULT_SIZE = 16;

    private int mask_; // mask for main arrays
    private int maskCollisions_; // mask for collision table
    private int numElems_; // tracks the size of the hashtable
    private final Selector.Method[] keys_; // array of keys
    private final Method[] values_; // array of values

    /**
     * If there is a collision, we keep the 'collided' elements in here (linked
     * list).
     */
    private final Binding[] collisions_;

    /**
     * Internal binding class. Stores a key, value, and a link to the next
     * binding in the chain.
     */
    static private final class Binding extends ovm.core.OVMBase {
        Binding link;
        Selector.Method key;
        Method value;
        Binding(Binding link, Selector.Method key, Method value) {
            this.link = link;
            this.key = key;
            this.value = value;
        }
    }

    /**
     * Public default constructor.
     */
    public HTSelector_Method2Method() {
        this(DEFAULT_SIZE);
    }

    /**
     * Constructor to build a new hashtable. The size hint passed is used to
     * choose the least power of 2 greater than the hint for the hashtable.
     */
    public HTSelector_Method2Method(int hint) {
        int size = 8;
        int sizeCollisions;
        while (size < hint)
            size *= 2;
        mask_ = size - 1;
        sizeCollisions = size >> 3;
        maskCollisions_ = sizeCollisions - 1;
        /* make collision table 1/8th of the size of the main table */
        this.collisions_ = new Binding[sizeCollisions];
        this.keys_ = new Selector.Method[size];
        this.values_ = new Method[size];

    }

    /**
     * Get a value from hashtable given a key. Returns the value NOTFOUND if
     * the key specified is not found in the hashtable.
     */
    public final Method get(Selector.Method key) {
        int hash = mask_ & key.hashCode();
        Selector.Method keys_hash = keys_[hash];
        if (keys_hash == null) {

            return NOTFOUND;
        }
        if (key.equals(keys_hash)) {

            return values_[hash];
        }
        return findInCollisions(maskCollisions_ & hash, key);
    }

    /**
     * Put a key and value into the hashtable. Checks to see if the key is
     * already in the hashtable, and if so, updates the value associated with
     * the key.
     */
    public final void put(Selector.Method key, Method value) {
        int hash = mask_ & key.hashCode();
        Selector.Method keys_hash = keys_[hash];
        if (keys_hash == null) { // simple insert
            numElems_++;
            keys_[hash] = key;
            values_[hash] = value;

            return;
        }
        if (key.equals(keys_hash)) { // replace
            values_[hash] = value;

            return;
        }
        // collision
        int hashCollision = hash & maskCollisions_;
        insertInCollisions(hashCollision, key, value);

    }

    /**
     * Return the size (number of elements currently present) of the hashtable.
     */
    public final int size() {
        return numElems_;
    }

    /**
     * Private function to search the collision table for a key value. Searches
     * the collisions_ table starting at the given offset until either the
     * correct Binding is found or the end of the list is reached.
     */
    private final Method findInCollisions(int offset, Selector.Method key) {
        Binding p;

        for (p = collisions_[offset]; p != null; p = p.link) {
            if (key.equals(p.key)) {
                return p.value;
            }

        }
        return NOTFOUND;
    }

    /**
     * Private function to insert a key and value into the collision table.
     * Searches the collisions_ table starting at the given offset and
     * continues until either the correct Binding is found, or the end of the
     * list is reached. If no Binding is found with the correct key, it will
     * create a new Binding to hold the key and value.
     */
    private final void insertInCollisions(
        int offset,
        Selector.Method key,
        Method value) {
        Binding h = collisions_[offset], p;

        for (p = h; p != null; p = p.link) {
            if (key.equals(p.key)) {
                p.value = value;

                return;
            }

        }

        collisions_[offset] = new Binding(h, key, value);
    }

} // End HTSel2Method
