# Precise stack walking with exception handlers and return address thunks

# this GC threshold only makes sense with a heap size of 60M
-gc-threshold "20M"

# Disable barriers?
#-disable-rtgc-barriers

-fixed-heap "-1"

ovm.core.services.memory.MemoryManager  \
 s3.services.memory.triPizlo.FakeScopeManWithAreaOf(heap-size, \
				                    gc-threshold,\
						    fixed-heap,\
						    disable-rtgc-barriers)

ovm.core.services.memory.LocalReferenceIterator			\
        s3.services.memory.conservative.ConservativeLocalReferenceIterator()

# How can we get -DPRECISE_THUNK set from here?  We could generate a file 
# called precise_config.hh that contains a #define.  The value to define
# would be a second ctor parameter.

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #


# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# Select the object model.  S3Model_B_M_F_H uses one word collocated with each
# object to store a blueprint reference, one to track monitor references, one
# to hold a forward address during collection, and one to hold the hash code
# (which can't be derived from the address after an object moves).  This is
# not a pleasingly space-efficient model.  But better ones can be implemented
# with the same functionality.
#
ovm.core.domain.ObjectModel		s3.core.domain.S3Model_Bg_Mf_F_H_S
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

# Add scope support to the context data structure.  
ovm.core.execution.Context$Factory	\
	ovm.core.services.memory.ScopedMemoryContext$Factory


%include "fast-lock"
