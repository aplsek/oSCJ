# InvisibleStitcher configuration file. stitchery is the default name
# the InvisibleStitcher will look for in the stitcher search path.
# The search path defaults to simply "config".  The name of the first
# file loaded, and the search path are controlled by the system
# properties ovm.stitcher.file and ovm.stitcher.path respectively.
#
# See java.util.Properties.load(...) for format. Because java.util.Properties
# is a hash table, the order of entries in a configuration file can carry no
# significance.  Each key (unless it is an option name beginning with - or the
# keyword %include) is a generic service interface or abstract class, and the
# value is the concrete implementation to be stitched in for it.
#
# If the value does not end with an argument list in parentheses, it will be
# instantiated using a no-arg constructor.  Otherwise it will be instantiated
# using a constructor that takes as many String parameters as there are
# arguments.  An argument can be a "-delimited string literal, for example
# "src:src/syslib/s3/ovm_rt.jar", or an option name (e.g. xdpath), or a system
# property name prefixed with % (e.g. %user.dir).
#
# If an option name, the value of the corresponding Driver command line
# argument (e.g. -xdpath=src:src/syslib/s3/ovm_rt.jar) will be passed to the
# constructor.  As described in the documentation for ovm.util.Options, an
# empty string will be passed if the option appears on the command line with
# no value, and null will be passed if the option doesn't appear.
#
# Values without an intervening comma are concatenated. So,
#     ovm.core.Foobie  s3.core.S3Foobie( %user.dir "/src")
# passes a single String to the S3Foobie constructor, the concatenation of the
# working directory and "/src".  The white space is needed to delimit the
# values: %user.dir"/src" would be an attempted reference to the system
# property user.dir"/src".
#
# A file may have exactly one property named %include, with one or more values
# separated by commas.  The values are exactly as above: quoted strings,
# option references, system property references, or concatenations thereof.
# The values are treated as URLs relative to the containing file, and included
# in the order specified.  Recursive inclusion is permitted to the limit of
# JVM stack depth. Cyclic inclusion will incur an exception.  Repeated inclusion
# has no effect.  The %include entry, if it appears anywhere in a file, is
# processed after all option setting entries (see next) and before all stitcher
# mapping entries.
#
# Any key whose name begins with - supplies a default value for a command-line
# option. For example,
#     -javadoc "file:" %user.dir "/doc"
# supplies a value to the command line option -javadoc if it is not already
# set. The value is visible in other configuration entries as the value javadoc
# and is also visible to the rest of the Ovm/tool when querying the
# CommandLine for the option.
#
# Command line options are documented by lines that begin with "##"
# and an optional space.  The stitcher usage message is generated by
# scanning all files on the config path for these lines, and stripping
# the prefix. Some options are built-in to the stitcher:
# 
## -?     prints this message
## -help  prints this message
## -debug enables stack traces on configuration errors
#
# The order of evaluation for entries in a config file is:
#  1. All option-setting entries, in an undetermined order
#  2. The %include entry, if any (multiple URLs are included in the order given)
#  3. All stitcher-mapping entries, in an undetermined order.
#
# Processing options before %include assures the useful behavior that an outer
# config file can supply default options that included files can refer to, or
# override options the included files set. For example:
#
#	   # foo
#	   -opt "Hello, world"
#	   %include "bar"
#
#	   # bar
#	   -opt "Nice try"
#	   ovm.core.Foobie  s3.core.S3Foobie( opt)
#
# In this example, "Hello, world" is the value of the -opt option (unless it
# was overridden on the command line), and the argument to the S3Foobie
# constructor. What you might find disappointing is that it won't work for an
# outer file to set an option with an expression that depends on something set
# in an included file. In this example:
#
#	   # foo
#	   %include "bar", "baz"
#	   -aa "do re " bb " sol la"  # no good
#          ovm.Stuff  s3.Thing( "do re " bb " sol la")  # works
#
#	   # bar
#	   -bb "mi fa"
#
#          # baz
#          ovm.Monster  s3.Burninator( "Gum" bb "lcons")
#
# Because option-setting expressions in foo all execute before %include, the
# option aa will be set only to "do re  sol la" (unless -bb was set to something
# on the command line).  On the other hand, because stitcher
# mappings are evaluated after %include, "do re mi fa sol la" is passed to
# the Thing constructor, and because %include URLs are handled in order,
# the Burninator constructor is indeed passed "Gummi falcons".
#
# An option-setting expression can have a comma-separated list of expressions, e.g.
#  -opt  opt1, opt2, "val3"
# setting opt to the value of the first expression whose value is
# defined.  In the example if -val2=yay were given on the command line
# but no -val1 then opt would be set to yay.  If neither opt1 nor opt2
# is defined, opt will be set to val3.  If no choice has a defined
# value, the value of the left-hand-side remains unchanged.
#
# To get a " inside a literal string, double it ("").  A doubled backslash \\
# gives a single backslash.  Other character transformations are performed
# by Properties.load (which see), allowing you to write a string literal of
# arbitrary length and content.
#
# If a line in this file ends with a \ then the newline and any whitespace
# beginning the continuation line are discarded.


# default configuration parameters and include files based on our settings

## -engine=E chooses the interpreter or compiler used to evaluate 
## 	bytecode (default j2c).
-engine			"j2c"

## -threads=T chooses a thread manager (default RealtimeJVM).
-threads		"RealtimeJVM"

## -io=I chooses an IO manager.  Various IO managers are provided
## 	to coordinate IO within a user-level threading system
# FIXME: Yeah, and exactly one is documented.  I have no idea when one
# even-and-io-manager would be prefered over another.
## 	(default SelectSockets_PollingOther).
-io			"SelectSockets_PollingOther"

## -model=G-H selects a memory manager (G), and an object header layout (H)
## 	(default MostlyCopyingSplitRegions-B_M_F_H).
-model			"MostlyCopyingSplitRegions-B_M_F_H"

## -analysis=A selects a static analysis implementation that is used
## 	statically link the application and guide optimizations
-analysis	"RTA"

## -transaction=VAL will tell the implementation to use PAR-style transactions
##  	values are true, false and stats.  Default is false
-transaction "false"

## -regress=true compiles the VM with builtin regression tests.  These
## 	tests can be run with ./ovm -doexectests (default false).
-regress      "false"

# There may be ordering constraints here.  At one time, the model would 
# set a flag called -movingGC, which the engine could then examine to decide
# how to deal with references in activations.  This flag is gone, but
# other subtle dependencies may remain.
%include "paths", \
	 "s3common", \
	 "threadserviceconfigurator/" threads "Configurator", \
	 "ioserviceconfigurator/" io "_IOServiceConfigurator", \
	 "model/" model, \
	 "engine/" engine, \
	 "analysis/" analysis, \
	 "transaction/" transaction, \
	 "regress-" regress
