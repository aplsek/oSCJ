## -bootclasspath=B specifies the location of OVM's runtime libraries
# This is overridden by real-time configurations to include the real-time libs
#
-bootclasspath	ovm_platform.jar ":" ovm_rt_user.jar

## -classpath=C specifies the search path for java applications

# The user-domain entry point. This is overridden for a RT config.
-udmain         "org.ovmj.java.Launcher"

# FIXME: should be xdbootpath, but evaluation order is screwed up
-xdpath		ovm_rt.jar ":" %java.class.path

# Every engine defines it's own set of helper macros for gdb
-gdbinit.in	native-dir "/" engine "/gdbinit.in"

## -ndebug       Disables diagnostic checks including and currently 
##               limited to vm-internal assert checking
# -ndebug

## -log=<comma-separated list of debug-logging options>, use -log=list
## 	to see a complete list of debug-logging options (default is empty
## 	if j2c is enabled or rewrite-errors otherwise).
-log		"rewrite-errors"

# Tune the size of build-time hashtables.  For fastest build times, choose 
# a number at least as large as the number of objects you expect to appear
# in the bootimage.
# 
# (Actually, our current version of IdentityHashMap interpreter the size 
# argument incorrectly.  Choose a number (ideally a prime) larger than
# the expected number of objects by a factor of 4/3.)
-build-size	"675001"

## -heap-size controls the total memory used for the OVM heap (with
## 	a copyhing garbage collector this is twice the maximum live heap 
## 	size).  Heap sizes may be specified in kilobytes, megabytes
## 	and gigabytes with the suffixes k, m, and g respectively.
## 	(Default 90m).
-heap-size	"90m"

## -main is a comma-separated list of classes this virtual
## 	machine may run as main.

## -reflective-method-trace=FILE will log all reflective method
## 	invocations to FILE in a format suitable for use with j2c's
## 	-ud-reflective-methods option.
#-reflective-method-trace "rmethods"

## -ud-reflective-methods=LIST is a whitespace-seperated list of all
##	methods invoked  reflectively in this configuration.  Each
##	method is written in the following format:
##		<internal class name><space><internal method descriptor>
##	For example, the method `public int bar( MyClass arg)' from
##	the class packfoo.Foo will be declared as
##		 Lpackfoo/Foo; bar:(I)LMyClass;
##	Note the colon between the method name and signature.
## 
##	Some people prefer to keep this list in a file with a name
##	such as method_list, and pass
##	-ud-reflective-methods=@method_list
##	on the command line.
-ud-reflective-methods	""

%include "reflection-helper"

## -reflective-class-trace=FILE will log all uses of Class.forName to
## 	FILE in a format suitable for use with the the
## 	-ud-reflective-classes option.
#-reflective-class-trace "rclasses"

## -ud-reflective-classes is a whitespace-seperated list of all
##	classes that are referenced through Class.forName, or
##	NAME.class expressions.  Each entry should be written in the
##	format Class.forName accepts.  For ordinary classes, this is a
##	fully qualified name, but for arrays, the format is a bit
##	unusual.  For example Object[] should be listed as
##	`[Ljava.lang.Object;', and int[] should be listed as `[I'
-ud-reflective-classes	""

# "true" if system bytecode rewriting (pragma, kernel, native call
# transformations) is to be applied to the application code, "false"
# or any other arbitrary string otherwise. This should be not "true"
# for a production configuration.
-system-rewrite-application-code        "false"

# FIXME: These settings should be controlled by a master optimization flag
# (like the one already used by j2c).  -simplejitopt should be controled 
# by the same flag

## -inline=<setting> controls Ovm's bytecode-level inliner.  Possible 
##                   settings are:
##	none   turns off inlining
##	light  inline small methods to improve build time
##	heavy  inline somewhat larger methods to improve run time
##      c0,c1  Set parameters that determine whether a method will be 
##	       inlined.  We inline a method if it's size in bytes is 
##	       less than c0 + c1 * <number of arguments>
##	By default, do not inline
-inline					"none"

## -inline-max-distinct-vars controls how the inliner picks indexes 
##	for the local variable in inlined methods.  Default is 85.
-inline-max-distinct-vars		"85"

## -preserve-variable-names controls how hard the inliner and j2c work to 
##	preserve the names of all local variables in the original program.  
##	Setting this option to false may improve execution speed.  Default 
##	value is true (currently ignored).
-preserve-variable-names		"true"

# common mappings from ovm APIs to s3 providers
ovm.core.Executive$Interface		s3.core.S3Executive(engine)

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# Select the domain directory implementation. S3DomainDirectory takes a
# classpath for the executive domain (which we find from the -xdpath
# makeImage option), and a user domain classpath--N.B. this user path is
# fixed, below, regardless of whether jamit is used.
#
# A real-time config will override this with a realtime domain directory
ovm.core.domain.DomainDirectory$Interface	\
                s3.core.domain.S3DomainDirectory(xdpath, \
						 bootclasspath, \
						 classpath, \
						 reflective-method-trace, \
						 reflective-class-trace)

ovm.core.execution.CoreServicesAccess$Factory \
	s3.core.execution.S3CoreServicesAccess$S3Factory
ovm.core.execution.Context$Factory \
	ovm.core.services.threads.OVMThreadContext$Factory

ovm.core.repository.Services            ovm.core.repository.Services
ovm.services.bytecode.reader.Services	s3.services.bytecode.reader.Services
# ovm.services.bytecode.Services		s3.services.bytecode.Services

# PosixIOImpl requires a UserLevelThreadManager (to disable GC during 
# read and write), so this default should be revisited if Configurator 
# stuff is ever better integrated with the invisible stitcher.
ovm.services.io.clients.PosixIO$Factory	\
	s3.services.io.clients.PosixIOImpl$Factory

# A stripped-down implementation of PosixIO that blocks the VM (actually
# the native thread) during IO calls.
#ovm.services.io.clients.PosixIO$Factory	\
#	s3.services.io.clients.BlockingPosixIOImpl$Factory

# Number of memory bytes that can be accessed by block copy/fill operations 
# between thread-switching safe points.  Mem.the().zero() will clear
# this many bytes before polling for a preemption request, and
# Mem.the().cpy() will copy half this many bytes
-thread-switch-byte-latency		"512"

# Select an implementation of memcpy, bzero, ...  The default
# implemenation honors the thread-switch-byte-latency parameter to
# avoid blocking other threads for the duration of a large
# byte-copying operation
ovm.util.Mem		ovm.util.Mem$PollingAware(thread-switch-byte-latency)

##   -emit-entry-pollcheck enables pollchecks on method entry
# -emit-entry-pollcheck

##   -emit-loop-pollcheck enables pollchecks on backward branches
-emit-loop-pollcheck	  "true"

##   -profile-natives enables profiling of native invocations.
# -profile-natives

# Choose appropriate implementations for 
# UnicodeBuffer.factory().wrap(String), and
# UnicodeBuffer.factory().toString() for this Executive Domain String class
ovm.util.UnicodeBuffer$Factory	     \
			s3.core.domain.S3ExecutiveDomain$UnicodeBufferFactory

ovm.core.services.memory.MemoryPolicy \
			ovm.core.services.memory.DefaultMemoryPolicy

ovm.core.execution.Trampoline	ovm.core.execution.NullTrampoline