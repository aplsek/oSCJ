package workload;

import java.io.DataOutputStream;
import java.io.IOException;
import java.lang.Math;

import cdx.Constants;
import cdx.ImmortalEntry;
import cdx.RawFrame;

import workload.FrameBuffer;

/**
 * Cyclic buffer of frames. Used for frames generated by simulator, but not yet processed by detector.
 * The memory is allocated at construction time and always re-used (frame data is copied in the same locations).
 * The frames, as well as the buffer, live in immortal memory. The constructor runs in immortal memory.
 * Note that the buffer is (intentionally) not synchronized. In a weird combination of priorities that is not
 * intended to be used, buffer frames could be overwritten.
 */
public class FrameBufferPLDI extends FrameBuffer {
	
	// empty buffer ... first == last
	// full buffer .... last + 1 == first
	//    - so there is still one empty slot, but we don't want to use it,
	//      because we would not then recognize empty from full buffer
	//
	// last .. where the next frame will be stored
	// first .. where the next frame will be read 

	public int first, last;
	public RawFrame[] frames;
    protected float t;
    protected int[] lengths; //= new int[] { 6, 6, 6,6, 6, 6,6, 6, 6,6, 6, 6,6, 6, 6,6, 6, 6,6, 6, 6,6, 6, 6,6, 6, 6,6, 6, 6,6, 6, 6,6, 6, 6,6, 6, 6,6, 6, 6,6, 6, 6,6, 6, 6,6, 6, 6,6, 6, 6,6, 6, 6, 6, 6, 6 };
    protected byte[] callsigns; //= new byte[60*6]; // { 112, 108, 97, 110, 101, 48, 112, 108, 97, 110, 101, 49, 112, 108, 97, 110, 101, 50, 112, 108, 97, 110, 101, 52, 48, 112, 108, 97, 110, 101, 52, 49, 112, 108, 97, 110, 101, 52, 50 };

    
    public FrameBufferPLDI() {
        if (Constants.FRAME_ON_THE_GO) {
            t=0.0f;
            lengths= new int[Constants.NUMBER_OF_PLANES];
            callsigns=new byte[Constants.NUMBER_OF_PLANES*6];
            for (int k=0;k<lengths.length;k++) lengths[k]=6;
        } else {
            frames = new RawFrame[Constants.BUFFER_FRAMES];
            for (int i = 0; i < Constants.BUFFER_FRAMES; i++) {
                frames[i] = new RawFrame();
            }
        }
	}
	
	public void putFrameInternal(final float[] positions_, final int[] lengths_, final byte[] callsigns_) {
        if (Constants.FRAME_ON_THE_GO) return;
        if ( (last + 1) % Constants.BUFFER_FRAMES == first) {
            ImmortalEntry.droppedFrames ++;
            return;
        }
        frames[last].copy(lengths_, callsigns_, positions_);
        last = (last + 1) % Constants.BUFFER_FRAMES; 
	}

	static int frameno = 0;

	public void putFrame(final float[] positions_, final int[] lengths_, final byte[] callsigns_) {
        if (Constants.FRAME_ON_THE_GO) return;
		if (Constants.SYNCHRONOUS_DETECTOR || Constants.DUMP_SENT_FRAMES) {
			String prefix = "S-FRAME " + frameno + " ";
			int offset = 0;
			for (int i=0;i<lengths_.length;i++) {

				int cslen = lengths_[i];
				System.out.println(prefix+new String( callsigns_, offset, cslen )+" "+
						positions_[3*i]+" "+
						positions_[3*i+1]+" "+
						positions_[3*i+2]+" ");
				offset += cslen;
			}        
			frameno++;
		}
		if (Constants.FRAMES_BINARY_DUMP) {
			// the binary format:
			//   nframes <INT>
			//
			//   nplanes <INT> 1
			//   positions <FLOAT> nplanes*3
			//   lengths <INT> nplanes
			//   callsigns_length <INT> 1
			//   callsigns <BYTE> callsigns_length
			
			DataOutputStream ds = ImmortalEntry.binaryDumpStream;
			
			try {
				ds.writeInt(lengths_.length);
			
				for(int i=0; i<lengths_.length; i++) {
					ds.writeFloat(positions_[3*i]);
					ds.writeFloat(positions_[3*i+1]);
					ds.writeFloat(positions_[3*i+2]);
				}
				
				for(int i=0;i<lengths_.length; i++) {
					ds.writeInt(lengths_[i]);
				}
				
				ds.writeInt(callsigns_.length);
				ds.write(callsigns_);
				
			} catch (IOException e) {
				throw new RuntimeException("Error dumping frames to binary file "+e);
			}
			
		}
		if (Constants.SYNCHRONOUS_DETECTOR) {
			//FrameSynchronizer.produceFrame();
		}
		putFrameInternal(positions_, lengths_, callsigns_);
		if (Constants.SYNCHRONOUS_DETECTOR) {
			//FrameSynchronizer.waitForConsumer();        
		}
	}

        

	public RawFrame getFrame() {
        if (Constants.FRAME_ON_THE_GO) {
            //RawFrame result=new RawFrame();
            
        	for (byte k=0;k<Constants.NUMBER_OF_PLANES;k++) {
                callsigns[6*k]=112;
                callsigns[6*k+1]=108;
                callsigns[6*k+2]=97;
                callsigns[6*k+3]=110;
                callsigns[6*k+4]=101;
                callsigns[6*k+5]=(byte)(49+k);
            }
            float positions[] = new float[60*3];
            
            for (int k=0;k<Constants.NUMBER_OF_PLANES/2;k++) {
                positions[3*k]=(float)(100*Math.cos(t)+500+50*k);
                positions[3*k+1]=100.0f;
                positions[3*k+2]=5.0f;
                positions[Constants.NUMBER_OF_PLANES/2*3+3*k]=(float)(100*Math.sin(t)+500+50*k);
                positions[Constants.NUMBER_OF_PLANES/2*3+3*k+1]=100.0f;
                positions[Constants.NUMBER_OF_PLANES/2*3+3*k+2]=5.0f;
            }
            // increase the time
            t=t+0.25f;
            buf.copy(lengths,callsigns,positions);
            return buf;
        } else {
            if (last == first) {
                return null;
            } else {
                final int f = first;
                first = (first + 1) % Constants.BUFFER_FRAMES;
                return frames[f];   // NOTE: if the simulator could run between this and the previous line,
                                    // it could corrupt the present frame
            }
        }
	}
}
